# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: sui/rpc/v2alpha/live_data_service.proto, sui/rpc/v2alpha/subscription_service.proto
# plugin: python-betterproto
# This file has been @generated

from collections.abc import AsyncIterator
from dataclasses import dataclass
from typing import TYPE_CHECKING

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from .. import v2beta as _v2_beta__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


class DynamicFieldDynamicFieldKind(betterproto.Enum):
    DYNAMIC_FIELD_KIND_UNKNOWN = 0
    FIELD = 1
    OBJECT = 2


@dataclass(eq=False, repr=False)
class GetCoinInfoRequest(betterproto.Message):
    """Request message for `NodeService.GetCoinInfo`."""

    coin_type: "str | None" = betterproto.string_field(1, optional=True)
    """The coin type to request information about"""


@dataclass(eq=False, repr=False)
class GetCoinInfoResponse(betterproto.Message):
    """Response message for `NodeService.GetCoinInfo`."""

    coin_type: "str | None" = betterproto.string_field(1, optional=True)
    """Required. The coin type."""

    metadata: "CoinMetadata | None" = betterproto.message_field(2, optional=True)
    """
    This field will be populated with information about this coin
     type's `0x2::coin::CoinMetadata` if it exists and has not been wrapped.
    """

    treasury: "CoinTreasury | None" = betterproto.message_field(3, optional=True)
    """
    This field will be populated with information about this coin
     type's `0x2::coin::TreasuryCap` if it exists and has not been wrapped.
    """

    regulated_metadata: "RegulatedCoinMetadata | None" = betterproto.message_field(
        4, optional=True
    )
    """
    If this coin type is a regulated coin, this field will be
     populated with information about its `0x2::coin::RegulatedCoinMetadata`
     object.
    """


@dataclass(eq=False, repr=False)
class CoinMetadata(betterproto.Message):
    """Metadata for a coin type"""

    id: "str | None" = betterproto.string_field(1, optional=True)
    """ObjectId of the `0x2::coin::CoinMetadata` object."""

    decimals: "int | None" = betterproto.uint32_field(2, optional=True)
    """Number of decimal places to coin uses."""

    name: "str | None" = betterproto.string_field(3, optional=True)
    """Name for the token"""

    symbol: "str | None" = betterproto.string_field(4, optional=True)
    """Symbol for the token"""

    description: "str | None" = betterproto.string_field(5, optional=True)
    """Description of the token"""

    icon_url: "str | None" = betterproto.string_field(6, optional=True)
    """URL for the token logo"""


@dataclass(eq=False, repr=False)
class CoinTreasury(betterproto.Message):
    """
    Information about a coin type's `0x2::coin::TreasuryCap` and its total available supply
    """

    id: "str | None" = betterproto.string_field(1, optional=True)
    """ObjectId of the `0x2::coin::TreasuryCap` object."""

    total_supply: "int | None" = betterproto.uint64_field(2, optional=True)
    """Total available supply for this coin type."""


@dataclass(eq=False, repr=False)
class RegulatedCoinMetadata(betterproto.Message):
    """
    Information about a regulated coin, which indicates that it makes use of the transfer deny list.
    """

    id: "str | None" = betterproto.string_field(1, optional=True)
    """ObjectId of the `0x2::coin::RegulatedCoinMetadata` object."""

    coin_metadata_object: "str | None" = betterproto.string_field(2, optional=True)
    """The ID of the coin's `CoinMetadata` object."""

    deny_cap_object: "str | None" = betterproto.string_field(3, optional=True)
    """The ID of the coin's `DenyCap` object."""


@dataclass(eq=False, repr=False)
class ListDynamicFieldsRequest(betterproto.Message):
    """Request message for `NodeService.ListDynamicFields`"""

    parent: "str | None" = betterproto.string_field(1, optional=True)
    """
    Required. The `UID` of the parent, which owns the collections of dynamic fields.
    """

    page_size: "int | None" = betterproto.uint32_field(2, optional=True)
    """
    The maximum number of dynamic fields to return. The service may return fewer than this value.
     If unspecified, at most `50` entries will be returned.
     The maximum value is `1000`; values above `1000` will be coerced to `1000`.
    """

    page_token: "bytes | None" = betterproto.bytes_field(3, optional=True)
    """
    A page token, received from a previous `ListDynamicFields` call.
     Provide this to retrieve the subsequent page.
    
     When paginating, all other parameters provided to `ListDynamicFields` must
     match the call that provided the page token.
    """


@dataclass(eq=False, repr=False)
class ListDynamicFieldsResponse(betterproto.Message):
    """Response message for `NodeService.ListDynamicFields`"""

    dynamic_fields: "list[DynamicField]" = betterproto.message_field(1)
    """Page of dynamic fields owned by the specified parent."""

    next_page_token: "bytes | None" = betterproto.bytes_field(2, optional=True)
    """
    A token, which can be sent as `page_token` to retrieve the next page.
     If this field is omitted, there are no subsequent pages.
    """


@dataclass(eq=False, repr=False)
class DynamicField(betterproto.Message):
    kind: "DynamicFieldDynamicFieldKind | None" = betterproto.enum_field(
        1, optional=True
    )
    parent: "str | None" = betterproto.string_field(2, optional=True)
    """ObjectId of this dynamic field's parent."""

    field_id: "str | None" = betterproto.string_field(3, optional=True)
    """ObjectId of this dynamic field."""

    name_type: "str | None" = betterproto.string_field(4, optional=True)
    """The type of the dynamic field "name"""

    name_value: "bytes | None" = betterproto.bytes_field(5, optional=True)
    """The serialized move value of "name"""

    value_type: "str | None" = betterproto.string_field(6, optional=True)
    """
    The type of the dynamic field "value".
    
     If this is a dynamic object field then this is the type of the object
     itself (which is a child of this field), otherwise this is the type of the
     value of this field.
    """

    dynamic_object_id: "str | None" = betterproto.string_field(7, optional=True)
    """
    The ObjectId of the child object when a child is a dynamic
     object field.
    
     The presence or absence of this field can be used to determine if a child
     is a dynamic field or a dynamic child object
    """


@dataclass(eq=False, repr=False)
class SimulateTransactionRequest(betterproto.Message):
    transaction: "_v2_beta__.Transaction | None" = betterproto.message_field(
        1, optional=True
    )
    read_mask: "betterproto_lib_google_protobuf.FieldMask | None" = (
        betterproto.message_field(2, optional=True)
    )


@dataclass(eq=False, repr=False)
class SimulateTransactionResponse(betterproto.Message):
    transaction: "_v2_beta__.ExecutedTransaction | None" = betterproto.message_field(
        1, optional=True
    )


@dataclass(eq=False, repr=False)
class ResolveTransactionRequest(betterproto.Message):
    unresolved_transaction: "_v2_beta__.Transaction | None" = betterproto.message_field(
        1, optional=True
    )
    read_mask: "betterproto_lib_google_protobuf.FieldMask | None" = (
        betterproto.message_field(2, optional=True)
    )


@dataclass(eq=False, repr=False)
class ResolveTransactionResponse(betterproto.Message):
    transaction: "_v2_beta__.Transaction | None" = betterproto.message_field(
        1, optional=True
    )
    simulation: "SimulateTransactionResponse | None" = betterproto.message_field(
        2, optional=True
    )


@dataclass(eq=False, repr=False)
class ListOwnedObjectsRequest(betterproto.Message):
    owner: "str | None" = betterproto.string_field(1, optional=True)
    """Required. The address of the account that owns the objects."""

    page_size: "int | None" = betterproto.uint32_field(2, optional=True)
    """
    The maximum number of entries return. The service may return fewer than this value.
     If unspecified, at most `50` entries will be returned.
     The maximum value is `1000`; values above `1000` will be coerced to `1000`.
    """

    page_token: "bytes | None" = betterproto.bytes_field(3, optional=True)
    """
    A page token, received from a previous `ListOwnedObjects` call.
     Provide this to retrieve the subsequent page.
    
     When paginating, all other parameters provided to `ListOwnedObjects` must
     match the call that provided the page token.
    """


@dataclass(eq=False, repr=False)
class ListOwnedObjectsResponse(betterproto.Message):
    objects: "list[OwnedObject]" = betterproto.message_field(1)
    """Page of dynamic fields owned by the specified parent."""

    next_page_token: "bytes | None" = betterproto.bytes_field(2, optional=True)
    """
    A token, which can be sent as `page_token` to retrieve the next page.
     If this field is omitted, there are no subsequent pages.
    """


@dataclass(eq=False, repr=False)
class OwnedObject(betterproto.Message):
    object_id: "str | None" = betterproto.string_field(2, optional=True)
    version: "int | None" = betterproto.uint64_field(3, optional=True)
    digest: "str | None" = betterproto.string_field(4, optional=True)
    owner: "_v2_beta__.Owner | None" = betterproto.message_field(5, optional=True)
    object_type: "str | None" = betterproto.string_field(6, optional=True)


@dataclass(eq=False, repr=False)
class SubscribeCheckpointsRequest(betterproto.Message):
    """Request message for SubscriptionService.SubscribeCheckpoints"""

    read_mask: "betterproto_lib_google_protobuf.FieldMask | None" = (
        betterproto.message_field(1, optional=True)
    )
    """
    Optional. Mask for specifiying which parts of the
     SubscribeCheckpointsResponse should be returned.
    """


@dataclass(eq=False, repr=False)
class SubscribeCheckpointsResponse(betterproto.Message):
    """Response message for SubscriptionService.SubscribeCheckpoints"""

    cursor: "int | None" = betterproto.uint64_field(1, optional=True)
    """
    Required. The checkpoint sequence number and value of the current cursor
     into the checkpoint stream
    """

    checkpoint: "_v2_beta__.Checkpoint | None" = betterproto.message_field(
        2, optional=True
    )
    """The requested data for this checkpoint"""


class LiveDataServiceStub(betterproto.ServiceStub):
    async def list_dynamic_fields(
        self,
        list_dynamic_fields_request: "ListDynamicFieldsRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None
    ) -> "ListDynamicFieldsResponse":
        return await self._unary_unary(
            "/sui.rpc.v2alpha.LiveDataService/ListDynamicFields",
            list_dynamic_fields_request,
            ListDynamicFieldsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_owned_objects(
        self,
        list_owned_objects_request: "ListOwnedObjectsRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None
    ) -> "ListOwnedObjectsResponse":
        return await self._unary_unary(
            "/sui.rpc.v2alpha.LiveDataService/ListOwnedObjects",
            list_owned_objects_request,
            ListOwnedObjectsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_coin_info(
        self,
        get_coin_info_request: "GetCoinInfoRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None
    ) -> "GetCoinInfoResponse":
        return await self._unary_unary(
            "/sui.rpc.v2alpha.LiveDataService/GetCoinInfo",
            get_coin_info_request,
            GetCoinInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def simulate_transaction(
        self,
        simulate_transaction_request: "SimulateTransactionRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None
    ) -> "SimulateTransactionResponse":
        return await self._unary_unary(
            "/sui.rpc.v2alpha.LiveDataService/SimulateTransaction",
            simulate_transaction_request,
            SimulateTransactionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def resolve_transaction(
        self,
        resolve_transaction_request: "ResolveTransactionRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None
    ) -> "ResolveTransactionResponse":
        return await self._unary_unary(
            "/sui.rpc.v2alpha.LiveDataService/ResolveTransaction",
            resolve_transaction_request,
            ResolveTransactionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class SubscriptionServiceStub(betterproto.ServiceStub):
    async def subscribe_checkpoints(
        self,
        subscribe_checkpoints_request: "SubscribeCheckpointsRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None
    ) -> "AsyncIterator[SubscribeCheckpointsResponse]":
        async for response in self._unary_stream(
            "/sui.rpc.v2alpha.SubscriptionService/SubscribeCheckpoints",
            subscribe_checkpoints_request,
            SubscribeCheckpointsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class LiveDataServiceBase(ServiceBase):

    async def list_dynamic_fields(
        self, list_dynamic_fields_request: "ListDynamicFieldsRequest"
    ) -> "ListDynamicFieldsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def list_owned_objects(
        self, list_owned_objects_request: "ListOwnedObjectsRequest"
    ) -> "ListOwnedObjectsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_coin_info(
        self, get_coin_info_request: "GetCoinInfoRequest"
    ) -> "GetCoinInfoResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def simulate_transaction(
        self, simulate_transaction_request: "SimulateTransactionRequest"
    ) -> "SimulateTransactionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def resolve_transaction(
        self, resolve_transaction_request: "ResolveTransactionRequest"
    ) -> "ResolveTransactionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_list_dynamic_fields(
        self,
        stream: "grpclib.server.Stream[ListDynamicFieldsRequest, ListDynamicFieldsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_dynamic_fields(request)
        await stream.send_message(response)

    async def __rpc_list_owned_objects(
        self,
        stream: "grpclib.server.Stream[ListOwnedObjectsRequest, ListOwnedObjectsResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.list_owned_objects(request)
        await stream.send_message(response)

    async def __rpc_get_coin_info(
        self, stream: "grpclib.server.Stream[GetCoinInfoRequest, GetCoinInfoResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.get_coin_info(request)
        await stream.send_message(response)

    async def __rpc_simulate_transaction(
        self,
        stream: "grpclib.server.Stream[SimulateTransactionRequest, SimulateTransactionResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.simulate_transaction(request)
        await stream.send_message(response)

    async def __rpc_resolve_transaction(
        self,
        stream: "grpclib.server.Stream[ResolveTransactionRequest, ResolveTransactionResponse]",
    ) -> None:
        request = await stream.recv_message()
        response = await self.resolve_transaction(request)
        await stream.send_message(response)

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/sui.rpc.v2alpha.LiveDataService/ListDynamicFields": grpclib.const.Handler(
                self.__rpc_list_dynamic_fields,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListDynamicFieldsRequest,
                ListDynamicFieldsResponse,
            ),
            "/sui.rpc.v2alpha.LiveDataService/ListOwnedObjects": grpclib.const.Handler(
                self.__rpc_list_owned_objects,
                grpclib.const.Cardinality.UNARY_UNARY,
                ListOwnedObjectsRequest,
                ListOwnedObjectsResponse,
            ),
            "/sui.rpc.v2alpha.LiveDataService/GetCoinInfo": grpclib.const.Handler(
                self.__rpc_get_coin_info,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetCoinInfoRequest,
                GetCoinInfoResponse,
            ),
            "/sui.rpc.v2alpha.LiveDataService/SimulateTransaction": grpclib.const.Handler(
                self.__rpc_simulate_transaction,
                grpclib.const.Cardinality.UNARY_UNARY,
                SimulateTransactionRequest,
                SimulateTransactionResponse,
            ),
            "/sui.rpc.v2alpha.LiveDataService/ResolveTransaction": grpclib.const.Handler(
                self.__rpc_resolve_transaction,
                grpclib.const.Cardinality.UNARY_UNARY,
                ResolveTransactionRequest,
                ResolveTransactionResponse,
            ),
        }


class SubscriptionServiceBase(ServiceBase):

    async def subscribe_checkpoints(
        self, subscribe_checkpoints_request: "SubscribeCheckpointsRequest"
    ) -> "AsyncIterator[SubscribeCheckpointsResponse]":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)
        yield SubscribeCheckpointsResponse()

    async def __rpc_subscribe_checkpoints(
        self,
        stream: "grpclib.server.Stream[SubscribeCheckpointsRequest, SubscribeCheckpointsResponse]",
    ) -> None:
        request = await stream.recv_message()
        await self._call_rpc_handler_server_stream(
            self.subscribe_checkpoints,
            stream,
            request,
        )

    def __mapping__(self) -> "dict[str, grpclib.const.Handler]":
        return {
            "/sui.rpc.v2alpha.SubscriptionService/SubscribeCheckpoints": grpclib.const.Handler(
                self.__rpc_subscribe_checkpoints,
                grpclib.const.Cardinality.UNARY_STREAM,
                SubscribeCheckpointsRequest,
                SubscribeCheckpointsResponse,
            ),
        }
