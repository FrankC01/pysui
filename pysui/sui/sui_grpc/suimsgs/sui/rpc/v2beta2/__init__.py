# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: sui/rpc/v2beta2/argument.proto, sui/rpc/v2beta2/balance_change.proto, sui/rpc/v2beta2/bcs.proto, sui/rpc/v2beta2/checkpoint.proto, sui/rpc/v2beta2/checkpoint_contents.proto, sui/rpc/v2beta2/checkpoint_summary.proto, sui/rpc/v2beta2/effects.proto, sui/rpc/v2beta2/epoch.proto, sui/rpc/v2beta2/error_reason.proto, sui/rpc/v2beta2/event.proto, sui/rpc/v2beta2/executed_transaction.proto, sui/rpc/v2beta2/execution_status.proto, sui/rpc/v2beta2/gas_cost_summary.proto, sui/rpc/v2beta2/input.proto, sui/rpc/v2beta2/ledger_service.proto, sui/rpc/v2beta2/live_data_service.proto, sui/rpc/v2beta2/move_package.proto, sui/rpc/v2beta2/move_package_service.proto, sui/rpc/v2beta2/object.proto, sui/rpc/v2beta2/object_reference.proto, sui/rpc/v2beta2/owner.proto, sui/rpc/v2beta2/protocol_config.proto, sui/rpc/v2beta2/signature.proto, sui/rpc/v2beta2/signature_scheme.proto, sui/rpc/v2beta2/signature_verification_service.proto, sui/rpc/v2beta2/subscription_service.proto, sui/rpc/v2beta2/system_state.proto, sui/rpc/v2beta2/transaction.proto, sui/rpc/v2beta2/transaction_execution_service.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "Ability",
    "ActiveJwk",
    "Argument",
    "ArgumentArgumentKind",
    "AuthenticatorStateExpire",
    "AuthenticatorStateUpdate",
    "Balance",
    "BalanceChange",
    "BatchGetObjectsRequest",
    "BatchGetObjectsResponse",
    "BatchGetTransactionsRequest",
    "BatchGetTransactionsResponse",
    "Bcs",
    "CanceledTransaction",
    "ChangeEpoch",
    "ChangedObject",
    "ChangedObjectIdOperation",
    "ChangedObjectInputObjectState",
    "ChangedObjectOutputObjectState",
    "Checkpoint",
    "CheckpointCommitment",
    "CheckpointCommitmentCheckpointCommitmentKind",
    "CheckpointContents",
    "CheckpointSummary",
    "CheckpointedTransactionInfo",
    "CircomG1",
    "CircomG2",
    "CleverError",
    "CoinDenyListError",
    "CoinMetadata",
    "CoinTreasury",
    "CoinTreasurySupplyState",
    "Command",
    "CommandArgumentError",
    "CommandArgumentErrorCommandArgumentErrorKind",
    "CommandOutput",
    "CommandResult",
    "CongestedObjects",
    "ConsensusCommitPrologue",
    "ConsensusDeterminedVersionAssignments",
    "DatatypeDescriptor",
    "DatatypeDescriptorDatatypeKind",
    "DynamicField",
    "DynamicFieldDynamicFieldKind",
    "EndOfEpochData",
    "EndOfEpochTransaction",
    "EndOfEpochTransactionKind",
    "Epoch",
    "ErrorReason",
    "Event",
    "ExecuteTransactionRequest",
    "ExecuteTransactionResponse",
    "ExecutedTransaction",
    "ExecutionError",
    "ExecutionErrorExecutionErrorKind",
    "ExecutionStatus",
    "ExecutionTimeObservation",
    "ExecutionTimeObservationExecutionTimeObservationKind",
    "ExecutionTimeObservations",
    "FieldDescriptor",
    "FunctionDescriptor",
    "FunctionDescriptorVisibility",
    "GasCostSummary",
    "GasPayment",
    "GenesisTransaction",
    "GetBalanceRequest",
    "GetBalanceResponse",
    "GetCheckpointRequest",
    "GetCheckpointResponse",
    "GetCoinInfoRequest",
    "GetCoinInfoResponse",
    "GetDatatypeRequest",
    "GetDatatypeResponse",
    "GetEpochRequest",
    "GetEpochResponse",
    "GetFunctionRequest",
    "GetFunctionResponse",
    "GetObjectRequest",
    "GetObjectResponse",
    "GetObjectResult",
    "GetPackageRequest",
    "GetPackageResponse",
    "GetServiceInfoRequest",
    "GetServiceInfoResponse",
    "GetTransactionRequest",
    "GetTransactionResponse",
    "GetTransactionResult",
    "IndexError",
    "Input",
    "InputInputKind",
    "Jwk",
    "JwkId",
    "LedgerServiceStub",
    "Linkage",
    "ListBalancesRequest",
    "ListBalancesResponse",
    "ListDynamicFieldsRequest",
    "ListDynamicFieldsResponse",
    "ListOwnedObjectsRequest",
    "ListOwnedObjectsResponse",
    "ListPackageVersionsRequest",
    "ListPackageVersionsResponse",
    "LiveDataServiceStub",
    "MakeMoveVector",
    "MergeCoins",
    "Module",
    "MoveAbort",
    "MoveCall",
    "MoveLocation",
    "MovePackageServiceStub",
    "MoveTable",
    "MultisigAggregatedSignature",
    "MultisigCommittee",
    "MultisigMember",
    "MultisigMemberPublicKey",
    "MultisigMemberSignature",
    "Object",
    "ObjectReference",
    "OpenSignature",
    "OpenSignatureBody",
    "OpenSignatureBodyType",
    "OpenSignatureReference",
    "Owner",
    "OwnerOwnerKind",
    "Package",
    "PackageUpgradeError",
    "PackageUpgradeErrorPackageUpgradeErrorKind",
    "PackageVersion",
    "PasskeyAuthenticator",
    "ProgrammableTransaction",
    "ProtocolConfig",
    "Publish",
    "RandomnessStateUpdate",
    "RegulatedCoinMetadata",
    "SignatureScheme",
    "SignatureVerificationServiceStub",
    "SimpleSignature",
    "SimulateTransactionRequest",
    "SimulateTransactionRequestTransactionChecks",
    "SimulateTransactionResponse",
    "SizeError",
    "SplitCoins",
    "StakeSubsidy",
    "StakingPool",
    "StorageFund",
    "SubscribeCheckpointsRequest",
    "SubscribeCheckpointsResponse",
    "SubscriptionServiceStub",
    "SystemPackage",
    "SystemParameters",
    "SystemState",
    "Transaction",
    "TransactionEffects",
    "TransactionEvents",
    "TransactionExecutionServiceStub",
    "TransactionExpiration",
    "TransactionExpirationTransactionExpirationKind",
    "TransactionFinality",
    "TransactionKind",
    "TransferObjects",
    "TypeArgumentError",
    "TypeArgumentErrorTypeArgumentErrorKind",
    "TypeOrigin",
    "TypeParameter",
    "UnchangedSharedObject",
    "UnchangedSharedObjectUnchangedSharedObjectKind",
    "Upgrade",
    "UserSignature",
    "Validator",
    "ValidatorAggregatedSignature",
    "ValidatorCommittee",
    "ValidatorCommitteeMember",
    "ValidatorExecutionTimeObservation",
    "ValidatorReportRecord",
    "ValidatorSet",
    "VariantDescriptor",
    "VerifySignatureRequest",
    "VerifySignatureResponse",
    "VersionAssignment",
    "ZkLoginAuthenticator",
    "ZkLoginClaim",
    "ZkLoginInputs",
    "ZkLoginProof",
    "ZkLoginPublicIdentifier",
)

import datetime
from collections.abc import AsyncIterator
from dataclasses import dataclass
from typing import TYPE_CHECKING

import betterproto2

from ....message_pool import default_message_pool

if TYPE_CHECKING:
    from betterproto2.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline

_COMPILER_VERSION = "0.7.1"
betterproto2.check_compiler_version(_COMPILER_VERSION)


class Ability(betterproto2.Enum):
    """
    An `Ability` classifies what operations are permitted for a given type
    """

    ABILITY_UNKNOWN = 0

    COPY = 1
    """
    Allows values of types with this ability to be copied
    """

    DROP = 2
    """
    Allows values of types with this ability to be dropped.
    """

    STORE = 3
    """
    Allows values of types with this ability to exist inside a struct in global storage
    """

    KEY = 4
    """
    Allows the type to serve as a key for global storage operations
    """


class ArgumentArgumentKind(betterproto2.Enum):
    ARGUMENT_KIND_UNKNOWN = 0

    GAS = 1
    """
    The gas coin.
    """

    INPUT = 2
    """
    One of the input objects or primitive values (from
    `ProgrammableTransaction` inputs).
    """

    RESULT = 3
    """
    The result of another command (from `ProgrammableTransaction` commands).
    """


class ChangedObjectIdOperation(betterproto2.Enum):
    ID_OPERATION_UNKNOWN = 0

    NONE = 1

    CREATED = 2

    DELETED = 3


class ChangedObjectInputObjectState(betterproto2.Enum):
    UNKNOWN = 0

    DOES_NOT_EXIST = 1

    EXISTS = 2

    betterproto_proto_names = {
        0: "INPUT_OBJECT_STATE_UNKNOWN",
        1: "INPUT_OBJECT_STATE_DOES_NOT_EXIST",
        2: "INPUT_OBJECT_STATE_EXISTS",
    }


class ChangedObjectOutputObjectState(betterproto2.Enum):
    UNKNOWN = 0

    DOES_NOT_EXIST = 1

    OBJECT_WRITE = 2

    PACKAGE_WRITE = 3

    betterproto_proto_names = {
        0: "OUTPUT_OBJECT_STATE_UNKNOWN",
        1: "OUTPUT_OBJECT_STATE_DOES_NOT_EXIST",
        2: "OUTPUT_OBJECT_STATE_OBJECT_WRITE",
        3: "OUTPUT_OBJECT_STATE_PACKAGE_WRITE",
    }


class CheckpointCommitmentCheckpointCommitmentKind(betterproto2.Enum):
    CHECKPOINT_COMMITMENT_KIND_UNKNOWN = 0

    ECMH_LIVE_OBJECT_SET = 1
    """
    An elliptic curve multiset hash attesting to the set of objects that
    comprise the live state of the Sui blockchain.
    """


class CoinTreasurySupplyState(betterproto2.Enum):
    """
    Supply state of a coin, matching the Move SupplyState enum
    """

    SUPPLY_STATE_UNKNOWN = 0
    """
    Supply is unknown or TreasuryCap still exists (minting still possible)
    """

    FIXED = 1
    """
    Supply is fixed (TreasuryCap consumed, no more minting possible)
    """


class CommandArgumentErrorCommandArgumentErrorKind(betterproto2.Enum):
    COMMAND_ARGUMENT_ERROR_KIND_UNKNOWN = 0

    TYPE_MISMATCH = 1
    """
    The type of the value does not match the expected type.
    """

    INVALID_BCS_BYTES = 2
    """
    The argument cannot be deserialized into a value of the specified type.
    """

    INVALID_USAGE_OF_PURE_ARGUMENT = 3
    """
    The argument cannot be instantiated from raw bytes.
    """

    INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION = 4
    """
    Invalid argument to private entry function.
    Private entry functions cannot take arguments from other Move functions.
    """

    INDEX_OUT_OF_BOUNDS = 5
    """
    Out of bounds access to input or results.

    `index` field will be set indicating the invalid index value.
    """

    SECONDARY_INDEX_OUT_OF_BOUNDS = 6
    """
    Out of bounds access to subresult.

    `index` and `subresult` fields will be set indicating the invalid index value.
    """

    INVALID_RESULT_ARITY = 7
    """
    Invalid usage of result.
    Expected a single result but found either no return value or multiple.
    `index` field will be set indicating the invalid index value.
    """

    INVALID_GAS_COIN_USAGE = 8
    """
    Invalid usage of gas coin.
    The gas coin can only be used by-value with a `TransferObject` command.
    """

    INVALID_VALUE_USAGE = 9
    """
    Invalid usage of Move value.
       - Mutably borrowed values require unique usage.
       - Immutably borrowed values cannot be taken or borrowed mutably.
       - Taken values cannot be used again.
    """

    INVALID_OBJECT_BY_VALUE = 10
    """
    Immutable objects cannot be passed by-value.
    """

    INVALID_OBJECT_BY_MUT_REF = 11
    """
    Immutable objects cannot be passed by mutable reference, `&mut`.
    """

    SHARED_OBJECT_OPERATION_NOT_ALLOWED = 12
    """
    Shared object operations such as wrapping, freezing, or converting to owned are not
    allowed.
    """

    INVALID_ARGUMENT_ARITY = 13
    """
    Invalid argument arity. Expected a single argument but found a result that expanded to
    multiple arguments.
    """


class DatatypeDescriptorDatatypeKind(betterproto2.Enum):
    DATATYPE_KIND_UNKNOWN = 0

    STRUCT = 1

    ENUM = 2


class DynamicFieldDynamicFieldKind(betterproto2.Enum):
    DYNAMIC_FIELD_KIND_UNKNOWN = 0

    FIELD = 1

    OBJECT = 2


class ErrorReason(betterproto2.Enum):
    ERROR_REASON_UNKNOWN = 0

    FIELD_INVALID = 1

    FIELD_MISSING = 2


class ExecutionErrorExecutionErrorKind(betterproto2.Enum):
    EXECUTION_ERROR_KIND_UNKNOWN = 0

    INSUFFICIENT_GAS = 1
    """
    Insufficient gas.
    """

    INVALID_GAS_OBJECT = 2
    """
    Invalid `Gas` object.
    """

    INVARIANT_VIOLATION = 3
    """
    Invariant violation.
    """

    FEATURE_NOT_YET_SUPPORTED = 4
    """
    Attempted to use feature that is not supported yet.
    """

    OBJECT_TOO_BIG = 5
    """
    Move object is larger than the maximum allowed size.
    """

    PACKAGE_TOO_BIG = 6
    """
    Package is larger than the maximum allowed size.
    """

    CIRCULAR_OBJECT_OWNERSHIP = 7
    """
    Circular object ownership.
    """

    INSUFFICIENT_COIN_BALANCE = 8
    """
    
    Coin errors.

    Insufficient coin balance for requested operation.
    """

    COIN_BALANCE_OVERFLOW = 9
    """
    Coin balance overflowed an u64.
    """

    PUBLISH_ERROR_NON_ZERO_ADDRESS = 10
    """
    
    Publish/Upgrade errors.

    Publish error, non-zero address.
    The modules in the package must have their self-addresses set to zero.
    """

    SUI_MOVE_VERIFICATION_ERROR = 11
    """
    Sui Move bytecode verification error.
    """

    MOVE_PRIMITIVE_RUNTIME_ERROR = 12
    """
    
    MoveVm errors.

    Error from a non-abort instruction.
    Possible causes:
        Arithmetic error, stack overflow, max value depth, or similar.
    """

    MOVE_ABORT = 13
    """
    Move runtime abort.
    """

    VM_VERIFICATION_OR_DESERIALIZATION_ERROR = 14
    """
    Bytecode verification error.
    """

    VM_INVARIANT_VIOLATION = 15
    """
    MoveVm invariant violation.
    """

    FUNCTION_NOT_FOUND = 16
    """
    
    Programmable transaction errors.

    Function not found.
    """

    ARITY_MISMATCH = 17
    """
    Parity mismatch for Move function.
    The number of arguments does not match the number of parameters.
    """

    TYPE_ARITY_MISMATCH = 18
    """
    Type parity mismatch for Move function.
    Mismatch between the number of actual versus expected type arguments.
    """

    NON_ENTRY_FUNCTION_INVOKED = 19
    """
    Non-entry function invoked. Move Call must start with an entry function.
    """

    COMMAND_ARGUMENT_ERROR = 20
    """
    Invalid command argument.
    """

    TYPE_ARGUMENT_ERROR = 21
    """
    Type argument error.
    """

    UNUSED_VALUE_WITHOUT_DROP = 22
    """
    Unused result without the drop ability.
    """

    INVALID_PUBLIC_FUNCTION_RETURN_TYPE = 23
    """
    Invalid public Move function signature.
    Unsupported return type for return value.
    """

    INVALID_TRANSFER_OBJECT = 24
    """
    Invalid transfer object, object does not have public transfer.
    """

    EFFECTS_TOO_LARGE = 25
    """
    
    Post-execution errors.

    Effects from the transaction are too large.
    """

    PUBLISH_UPGRADE_MISSING_DEPENDENCY = 26
    """
    Publish or Upgrade is missing dependency.
    """

    PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE = 27
    """
    Publish or upgrade dependency downgrade.

    Indirect (transitive) dependency of published or upgraded package has been assigned an
    on-chain version that is less than the version required by one of the package's
    transitive dependencies.
    """

    PACKAGE_UPGRADE_ERROR = 28
    """
    Invalid package upgrade.
    """

    WRITTEN_OBJECTS_TOO_LARGE = 29
    """
    Indicates the transaction tried to write objects too large to storage.
    """

    CERTIFICATE_DENIED = 30
    """
    Certificate is on the deny list.
    """

    SUI_MOVE_VERIFICATION_TIMEDOUT = 31
    """
    Sui Move bytecode verification timed out.
    """

    SHARED_OBJECT_OPERATION_NOT_ALLOWED = 32
    """
    The requested shared object operation is not allowed.
    """

    INPUT_OBJECT_DELETED = 33
    """
    Requested shared object has been deleted.
    """

    EXECUTION_CANCELED_DUE_TO_SHARED_OBJECT_CONGESTION = 34
    """
    Certificate is canceled due to congestion on shared objects.
    """

    ADDRESS_DENIED_FOR_COIN = 35
    """
    Address is denied for this coin type.
    """

    COIN_TYPE_GLOBAL_PAUSE = 36
    """
    Coin type is globally paused for use.
    """

    EXECUTION_CANCELED_DUE_TO_RANDOMNESS_UNAVAILABLE = 37
    """
    Certificate is canceled because randomness could not be generated this epoch.
    """

    MOVE_VECTOR_ELEM_TOO_BIG = 38

    MOVE_RAW_VALUE_TOO_BIG = 39

    INVALID_LINKAGE = 40


class ExecutionTimeObservationExecutionTimeObservationKind(betterproto2.Enum):
    EXECUTION_TIME_OBSERVATION_KIND_UNKNOWN = 0

    MOVE_ENTRY_POINT = 1

    TRANSFER_OBJECTS = 2

    SPLIT_COINS = 3

    MERGE_COINS = 4

    PUBLISH = 5

    MAKE_MOVE_VECTOR = 6

    UPGRADE = 7


class FunctionDescriptorVisibility(betterproto2.Enum):
    VISIBILITY_UNKNOWN = 0

    PRIVATE = 1

    PUBLIC = 2

    FRIEND = 3


class InputInputKind(betterproto2.Enum):
    INPUT_KIND_UNKNOWN = 0

    PURE = 1
    """
    A move value serialized as BCS.
    """

    IMMUTABLE_OR_OWNED = 2
    """
    A Move object that is either immutable or address owned.
    """

    SHARED = 3
    """
    A Move object whose owner is "Shared".
    """

    RECEIVING = 4
    """
    A Move object that is attempted to be received in this transaction.
    """


class OpenSignatureReference(betterproto2.Enum):
    REFERENCE_UNKNOWN = 0

    IMMUTABLE = 1

    MUTABLE = 2


class OpenSignatureBodyType(betterproto2.Enum):
    TYPE_UNKNOWN = 0

    ADDRESS = 1

    BOOL = 2

    U8 = 3

    U16 = 4

    U32 = 5

    U64 = 6

    U128 = 7

    U256 = 8

    VECTOR = 9

    DATATYPE = 10

    TYPE_PARAMETER = 11


class OwnerOwnerKind(betterproto2.Enum):
    OWNER_KIND_UNKNOWN = 0

    ADDRESS = 1

    OBJECT = 2

    SHARED = 3

    IMMUTABLE = 4

    CONSENSUS_ADDRESS = 5


class PackageUpgradeErrorPackageUpgradeErrorKind(betterproto2.Enum):
    PACKAGE_UPGRADE_ERROR_KIND_UNKNOWN = 0

    UNABLE_TO_FETCH_PACKAGE = 1
    """
    Unable to fetch package.
    """

    NOT_A_PACKAGE = 2
    """
    Object is not a package.
    """

    INCOMPATIBLE_UPGRADE = 3
    """
    Package upgrade is incompatible with previous version.
    """

    DIGEST_DOES_NOT_MATCH = 4
    """
    Digest in upgrade ticket and computed digest differ.
    """

    UNKNOWN_UPGRADE_POLICY = 5
    """
    Upgrade policy is not valid.
    """

    PACKAGE_ID_DOES_NOT_MATCH = 6
    """
    Package ID does not match `PackageId` in upgrade ticket.
    """


class SignatureScheme(betterproto2.Enum):
    """
    Flag use to disambiguate the signature schemes supported by Sui.

    Note: the enum values defined by this proto message exactly match their
    expected BCS serialized values when serialized as a u8. See
    [enum.SignatureScheme](https://mystenlabs.github.io/sui-rust-sdk/sui_sdk_types/enum.SignatureScheme.html)
    for more information about signature schemes.
    """

    ED25519 = 0

    SECP256K1 = 1

    SECP256R1 = 2

    MULTISIG = 3

    BLS12381 = 4

    ZKLOGIN = 5

    PASSKEY = 6


class SimulateTransactionRequestTransactionChecks(betterproto2.Enum):
    """
    buf:lint:ignore ENUM_ZERO_VALUE_SUFFIX
    """

    ENABLED = 0

    DISABLED = 1


class TransactionExpirationTransactionExpirationKind(betterproto2.Enum):
    TRANSACTION_EXPIRATION_KIND_UNKNOWN = 0

    NONE = 1
    """
    The transaction has no expiration.
    """

    EPOCH = 2
    """
    Validators won't sign and execute transaction unless the expiration epoch
    is greater than or equal to the current epoch.
    """


class TypeArgumentErrorTypeArgumentErrorKind(betterproto2.Enum):
    TYPE_ARGUMENT_ERROR_KIND_UNKNOWN = 0

    TYPE_NOT_FOUND = 1
    """
    A type was not found in the module specified.
    """

    CONSTRAINT_NOT_SATISFIED = 2
    """
    A type provided did not match the specified constraint.
    """


class UnchangedSharedObjectUnchangedSharedObjectKind(betterproto2.Enum):
    UNCHANGED_SHARED_OBJECT_KIND_UNKNOWN = 0

    READ_ONLY_ROOT = 1
    """
    Read-only shared object from the input.
    """

    MUTATE_CONSENSUS_STREAM_ENDED = 2
    """
    Objects with ended consensus streams that appear mutably/owned in the input.
    """

    READ_CONSENSUS_STREAM_ENDED = 3
    """
    Objects with ended consensus streams objects that appear as read-only in the input.
    """

    CANCELED = 4
    """
    Consensus objects that were congested and resulted in this transaction being
    canceled.
    """

    PER_EPOCH_CONFIG = 5
    """
    Read of a per-epoch config object that should remain the same during an
    epoch. This optionally will indicate the sequence number of the config
    object at the start of the epoch.
    """


@dataclass(eq=False, repr=False)
class ActiveJwk(betterproto2.Message):
    """
    A new JWK.
    """

    id: "JwkId | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    """
    Identifier used to uniquely identify a JWK.
    """

    jwk: "Jwk | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)
    """
    The JWK.
    """

    epoch: "int | None" = betterproto2.field(3, betterproto2.TYPE_UINT64, optional=True)
    """
    Most recent epoch in which the JWK was validated.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "ActiveJwk", ActiveJwk)


@dataclass(eq=False, repr=False)
class Argument(betterproto2.Message):
    """
    An argument to a programmable transaction command.
    """

    kind: "ArgumentArgumentKind | None" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, optional=True
    )

    input: "int | None" = betterproto2.field(2, betterproto2.TYPE_UINT32, optional=True)
    """
    Index of an input when `kind` is `INPUT`.
    """

    result: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT32, optional=True
    )
    """
    Index of a result when `kind` is `RESULT`.
    """

    subresult: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT32, optional=True
    )
    """
    Used to access a nested result when `kind` is `RESULT`.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "Argument", Argument)


@dataclass(eq=False, repr=False)
class AuthenticatorStateExpire(betterproto2.Message):
    """
    Expire old JWKs.
    """

    min_epoch: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Expire JWKs that have a lower epoch than this.
    """

    authenticator_object_initial_shared_version: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The initial version of the authenticator object that it was shared at.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "AuthenticatorStateExpire", AuthenticatorStateExpire
)


@dataclass(eq=False, repr=False)
class AuthenticatorStateUpdate(betterproto2.Message):
    """
    Update the set of valid JWKs.
    """

    epoch: "int | None" = betterproto2.field(1, betterproto2.TYPE_UINT64, optional=True)
    """
    Epoch of the authenticator state update transaction.
    """

    round: "int | None" = betterproto2.field(2, betterproto2.TYPE_UINT64, optional=True)
    """
    Consensus round of the authenticator state update.
    """

    new_active_jwks: "list[ActiveJwk]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Newly active JWKs.
    """

    authenticator_object_initial_shared_version: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The initial version of the authenticator object that it was shared at.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "AuthenticatorStateUpdate", AuthenticatorStateUpdate
)


@dataclass(eq=False, repr=False)
class Balance(betterproto2.Message):
    """
    Balance information for a specific coin type.
    """

    coin_type: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    The type of the coin (e.g., 0x2::sui::SUI).
    """

    balance: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Shows the total balance of the coin in its smallest unit.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "Balance", Balance)


@dataclass(eq=False, repr=False)
class BalanceChange(betterproto2.Message):
    """
    The delta, or change, in balance for an address for a particular `Coin` type.
    """

    address: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    The account address that is affected by this balance change event.
    """

    coin_type: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    The `Coin` type of this balance change event.
    """

    amount: "str | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True
    )
    """
    The amount or change in balance.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "BalanceChange", BalanceChange)


@dataclass(eq=False, repr=False)
class BatchGetObjectsRequest(betterproto2.Message):
    requests: "list[GetObjectRequest]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )

    read_mask: "___google__protobuf__.FieldMask | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Mask specifying which fields to read.
    If no mask is specified, defaults to `object_id,version,digest`.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "BatchGetObjectsRequest", BatchGetObjectsRequest
)


@dataclass(eq=False, repr=False)
class BatchGetObjectsResponse(betterproto2.Message):
    objects: "list[GetObjectResult]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "BatchGetObjectsResponse", BatchGetObjectsResponse
)


@dataclass(eq=False, repr=False)
class BatchGetTransactionsRequest(betterproto2.Message):
    digests: "list[str]" = betterproto2.field(
        1, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Required. The digests of the requested transactions.
    """

    read_mask: "___google__protobuf__.FieldMask | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Mask specifying which fields to read.
    If no mask is specified, defaults to `object_id,version,digest`.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "BatchGetTransactionsRequest", BatchGetTransactionsRequest
)


@dataclass(eq=False, repr=False)
class BatchGetTransactionsResponse(betterproto2.Message):
    transactions: "list[GetTransactionResult]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "BatchGetTransactionsResponse", BatchGetTransactionsResponse
)


@dataclass(eq=False, repr=False)
class Bcs(betterproto2.Message):
    """
    `Bcs` contains an arbitrary type that is serialized using the
    [BCS](https://mystenlabs.github.io/sui-rust-sdk/sui_sdk_types/index.html#bcs)
    format as well as a name that identifies the type of the serialized value.
    """

    name: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    Name that identifies the type of the serialized value.
    """

    value: "bytes | None" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, optional=True
    )
    """
    Bytes of a BCS serialized value.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "Bcs", Bcs)


@dataclass(eq=False, repr=False)
class CanceledTransaction(betterproto2.Message):
    """
    A transaction that was canceled.
    """

    digest: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    Digest of the canceled transaction.
    """

    version_assignments: "list[VersionAssignment]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of object version assignments.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "CanceledTransaction", CanceledTransaction
)


@dataclass(eq=False, repr=False)
class ChangedObject(betterproto2.Message):
    """
    Input/output state of an object that was changed during execution.
    """

    object_id: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    ID of the object.
    """

    input_state: "ChangedObjectInputObjectState | None" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, optional=True
    )

    input_version: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Version of the object before this transaction executed.
    """

    input_digest: "str | None" = betterproto2.field(
        4, betterproto2.TYPE_STRING, optional=True
    )
    """
    Digest of the object before this transaction executed.
    """

    input_owner: "Owner | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Owner of the object before this transaction executed.
    """

    output_state: "ChangedObjectOutputObjectState | None" = betterproto2.field(
        6, betterproto2.TYPE_ENUM, optional=True
    )

    output_version: "int | None" = betterproto2.field(
        7, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Version of the object after this transaction executed.
    """

    output_digest: "str | None" = betterproto2.field(
        8, betterproto2.TYPE_STRING, optional=True
    )
    """
    Digest of the object after this transaction executed.
    """

    output_owner: "Owner | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Owner of the object after this transaction executed.
    """

    id_operation: "ChangedObjectIdOperation | None" = betterproto2.field(
        10, betterproto2.TYPE_ENUM, optional=True
    )
    """
    What happened to an `ObjectId` during execution.
    """

    object_type: "str | None" = betterproto2.field(
        11, betterproto2.TYPE_STRING, optional=True
    )
    """
    Type information is not provided by the effects structure but is instead
    provided by an indexing layer
    """


default_message_pool.register_message("sui.rpc.v2beta2", "ChangedObject", ChangedObject)


@dataclass(eq=False, repr=False)
class ChangeEpoch(betterproto2.Message):
    """
    System transaction used to change the epoch.
    """

    epoch: "int | None" = betterproto2.field(1, betterproto2.TYPE_UINT64, optional=True)
    """
    The next (to become) epoch ID.
    """

    protocol_version: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The protocol version in effect in the new epoch.
    """

    storage_charge: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The total amount of gas charged for storage during the epoch.
    """

    computation_charge: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The total amount of gas charged for computation during the epoch.
    """

    storage_rebate: "int | None" = betterproto2.field(
        5, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The amount of storage rebate refunded to the txn senders.
    """

    non_refundable_storage_fee: "int | None" = betterproto2.field(
        6, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The non-refundable storage fee.
    """

    epoch_start_timestamp: "datetime.datetime | None" = betterproto2.field(
        7,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Timestamp,
        optional=True,
    )
    """
    Unix timestamp when epoch started.
    """

    system_packages: "list[SystemPackage]" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    System packages (specifically framework and Move stdlib) that are written before the new
    epoch starts. This tracks framework upgrades on chain. When executing the `ChangeEpoch` txn,
    the validator must write out the following modules.  Modules are provided with the version they
    will be upgraded to, their modules in serialized form (which include their package ID), and
    a list of their transitive dependencies.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "ChangeEpoch", ChangeEpoch)


@dataclass(eq=False, repr=False)
class Checkpoint(betterproto2.Message):
    sequence_number: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The height of this checkpoint.
    """

    digest: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    The digest of this Checkpoint's CheckpointSummary.
    """

    summary: "CheckpointSummary | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The `CheckpointSummary` for this checkpoint.
    """

    signature: "ValidatorAggregatedSignature | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    An aggregated quorum signature from the validator committee that
    certified this checkpoint.
    """

    contents: "CheckpointContents | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The `CheckpointContents` for this checkpoint.
    """

    transactions: "list[ExecutedTransaction]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of transactions included in this checkpoint.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "Checkpoint", Checkpoint)


@dataclass(eq=False, repr=False)
class CheckpointCommitment(betterproto2.Message):
    """
    A commitment made by a checkpoint.
    """

    kind: "CheckpointCommitmentCheckpointCommitmentKind | None" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, optional=True
    )

    digest: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "CheckpointCommitment", CheckpointCommitment
)


@dataclass(eq=False, repr=False)
class CheckpointContents(betterproto2.Message):
    """
    The committed to contents of a checkpoint.
    """

    bcs: "Bcs | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    """
    This CheckpointContents serialized as BCS.
    """

    digest: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    The digest of this CheckpointContents.
    """

    version: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_INT32, optional=True
    )
    """
    Version of this CheckpointContents
    """

    transactions: "list[CheckpointedTransactionInfo]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Set of transactions committed to in this checkpoint.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "CheckpointContents", CheckpointContents
)


@dataclass(eq=False, repr=False)
class CheckpointedTransactionInfo(betterproto2.Message):
    """
    Transaction information committed to in a checkpoint.
    """

    transaction: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    Digest of the transaction.
    """

    effects: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    Digest of the effects.
    """

    signatures: "list[UserSignature]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Set of user signatures that authorized the transaction.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "CheckpointedTransactionInfo", CheckpointedTransactionInfo
)


@dataclass(eq=False, repr=False)
class CheckpointSummary(betterproto2.Message):
    """
    A header for a checkpoint on the Sui blockchain.

    On the Sui network, checkpoints define the history of the blockchain. They are quite similar to
    the concept of blocks used by other blockchains like Bitcoin or Ethereum. The Sui blockchain,
    however, forms checkpoints after transaction execution has already happened to provide a
    certified history of the chain, instead of being formed before execution.

    Checkpoints commit to a variety of state, including but not limited to:
    - The hash of the previous checkpoint.
    - The set of transaction digests, their corresponding effects digests, as well as the set of
      user signatures that authorized its execution.
    - The objects produced by a transaction.
    - The set of live objects that make up the current state of the chain.
    - On epoch transitions, the next validator committee.

    `CheckpointSummary`s themselves don't directly include all of the previous information but they
    are the top-level type by which all the information is committed to transitively via cryptographic
    hashes included in the summary. `CheckpointSummary`s are signed and certified by a quorum of
    the validator committee in a given epoch to allow verification of the chain's state.
    """

    bcs: "Bcs | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    """
    This CheckpointSummary serialized as BCS.
    """

    digest: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    The digest of this CheckpointSummary.
    """

    epoch: "int | None" = betterproto2.field(3, betterproto2.TYPE_UINT64, optional=True)
    """
    Epoch that this checkpoint belongs to.
    """

    sequence_number: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The height of this checkpoint.
    """

    total_network_transactions: "int | None" = betterproto2.field(
        5, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Total number of transactions committed since genesis, including those in this
    checkpoint.
    """

    content_digest: "str | None" = betterproto2.field(
        6, betterproto2.TYPE_STRING, optional=True
    )
    """
    The hash of the `CheckpointContents` for this checkpoint.
    """

    previous_digest: "str | None" = betterproto2.field(
        7, betterproto2.TYPE_STRING, optional=True
    )
    """
    The hash of the previous `CheckpointSummary`.

    This will be `None` only for the first, or genesis, checkpoint.
    """

    epoch_rolling_gas_cost_summary: "GasCostSummary | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The running total gas costs of all transactions included in the current epoch so far
    until this checkpoint.
    """

    timestamp: "datetime.datetime | None" = betterproto2.field(
        9,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Timestamp,
        optional=True,
    )
    """
    Timestamp of the checkpoint - number of milliseconds from the Unix epoch
    Checkpoint timestamps are monotonic, but not strongly monotonic - subsequent
    checkpoints can have the same timestamp if they originate from the same underlining consensus commit.
    """

    commitments: "list[CheckpointCommitment]" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Commitments to checkpoint-specific state.
    """

    end_of_epoch_data: "EndOfEpochData | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Extra data only present in the final checkpoint of an epoch.
    """

    version_specific_data: "bytes | None" = betterproto2.field(
        12, betterproto2.TYPE_BYTES, optional=True
    )
    """
    `CheckpointSummary` is not an evolvable structure - it must be readable by any version of
    the code. Therefore, to allow extensions to be added to `CheckpointSummary`,
    opaque data can be added to checkpoints, which can be deserialized based on the current
    protocol version.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "CheckpointSummary", CheckpointSummary
)


@dataclass(eq=False, repr=False)
class CircomG1(betterproto2.Message):
    """
    A G1 point.
    """

    e0: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    base10 encoded Bn254FieldElement
    """

    e1: "str | None" = betterproto2.field(2, betterproto2.TYPE_STRING, optional=True)
    """
    base10 encoded Bn254FieldElement
    """

    e2: "str | None" = betterproto2.field(3, betterproto2.TYPE_STRING, optional=True)
    """
    base10 encoded Bn254FieldElement
    """


default_message_pool.register_message("sui.rpc.v2beta2", "CircomG1", CircomG1)


@dataclass(eq=False, repr=False)
class CircomG2(betterproto2.Message):
    """
    A G2 point.
    """

    e00: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    base10 encoded Bn254FieldElement
    """

    e01: "str | None" = betterproto2.field(2, betterproto2.TYPE_STRING, optional=True)
    """
    base10 encoded Bn254FieldElement
    """

    e10: "str | None" = betterproto2.field(3, betterproto2.TYPE_STRING, optional=True)
    """
    base10 encoded Bn254FieldElement
    """

    e11: "str | None" = betterproto2.field(4, betterproto2.TYPE_STRING, optional=True)
    """
    base10 encoded Bn254FieldElement
    """

    e20: "str | None" = betterproto2.field(5, betterproto2.TYPE_STRING, optional=True)
    """
    base10 encoded Bn254FieldElement
    """

    e21: "str | None" = betterproto2.field(6, betterproto2.TYPE_STRING, optional=True)
    """
    base10 encoded Bn254FieldElement
    """


default_message_pool.register_message("sui.rpc.v2beta2", "CircomG2", CircomG2)


@dataclass(eq=False, repr=False)
class CleverError(betterproto2.Message):
    """


    Oneofs:
        - value:
    """

    error_code: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_UINT64, optional=True
    )

    line_number: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )

    constant_name: "str | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True
    )

    constant_type: "str | None" = betterproto2.field(
        4, betterproto2.TYPE_STRING, optional=True
    )

    rendered: "str | None" = betterproto2.field(
        5, betterproto2.TYPE_STRING, optional=True, group="value"
    )

    raw: "bytes | None" = betterproto2.field(
        6, betterproto2.TYPE_BYTES, optional=True, group="value"
    )


default_message_pool.register_message("sui.rpc.v2beta2", "CleverError", CleverError)


@dataclass(eq=False, repr=False)
class CoinDenyListError(betterproto2.Message):
    address: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    Denied address.
    """

    coin_type: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    Coin type.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "CoinDenyListError", CoinDenyListError
)


@dataclass(eq=False, repr=False)
class CoinMetadata(betterproto2.Message):
    """
    Metadata for a coin type
    """

    id: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    ObjectId of the `0x2::coin::CoinMetadata` object or
    0x2::sui::coin_registry::CoinData object (when registered with CoinRegistry).
    """

    decimals: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT32, optional=True
    )
    """
    Number of decimal places to coin uses.
    """

    name: "str | None" = betterproto2.field(3, betterproto2.TYPE_STRING, optional=True)
    """
    Name for the token
    """

    symbol: "str | None" = betterproto2.field(
        4, betterproto2.TYPE_STRING, optional=True
    )
    """
    Symbol for the token
    """

    description: "str | None" = betterproto2.field(
        5, betterproto2.TYPE_STRING, optional=True
    )
    """
    Description of the token
    """

    icon_url: "str | None" = betterproto2.field(
        6, betterproto2.TYPE_STRING, optional=True
    )
    """
    URL for the token logo
    """

    metadata_cap_id: "str | None" = betterproto2.field(
        7, betterproto2.TYPE_STRING, optional=True
    )
    """
    The MetadataCap ID if it has been claimed for this coin type.
    This capability allows updating the coin's metadata fields.
    Only populated when metadata is from CoinRegistry.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "CoinMetadata", CoinMetadata)


@dataclass(eq=False, repr=False)
class CoinTreasury(betterproto2.Message):
    """
    Information about a coin type's `0x2::coin::TreasuryCap` and its total available supply
    """

    id: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    ObjectId of the `0x2::coin::TreasuryCap` object.
    """

    total_supply: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Total available supply for this coin type.
    """

    supply_state: "CoinTreasurySupplyState | None" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, optional=True
    )
    """
    Supply state indicating if the supply is fixed or can still be minted
    """


default_message_pool.register_message("sui.rpc.v2beta2", "CoinTreasury", CoinTreasury)


@dataclass(eq=False, repr=False)
class Command(betterproto2.Message):
    """
    A single command in a programmable transaction.

    Oneofs:
        - command:
    """

    move_call: "MoveCall | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="command"
    )
    """
    A call to either an entry or a public Move function.
    """

    transfer_objects: "TransferObjects | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="command"
    )
    """
    `(Vec<forall T:key+store. T>, address)`
    It sends n-objects to the specified address. These objects must have store
    (public transfer) and either the previous owner must be an address or the object must
    be newly created.
    """

    split_coins: "SplitCoins | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="command"
    )
    """
    `(&mut Coin<T>, Vec<u64>)` -> `Vec<Coin<T>>`
    It splits off some amounts into new coins with those amounts.
    """

    merge_coins: "MergeCoins | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="command"
    )
    """
    `(&mut Coin<T>, Vec<Coin<T>>)`
    It merges n-coins into the first coin.
    """

    publish: "Publish | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="command"
    )
    """
    Publishes a Move package. It takes the package bytes and a list of the package's transitive
    dependencies to link against on chain.
    """

    make_move_vector: "MakeMoveVector | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="command"
    )
    """
    `forall T: Vec<T> -> vector<T>`
    Given n-values of the same type, it constructs a vector. For non-objects or an empty vector,
    the type tag must be specified.
    """

    upgrade: "Upgrade | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="command"
    )
    """
    Upgrades a Move package.
    Takes (in order):
    1. A vector of serialized modules for the package.
    2. A vector of object ids for the transitive dependencies of the new package.
    3. The object ID of the package being upgraded.
    4. An argument holding the `UpgradeTicket` that must have been produced from an earlier command in the same
       programmable transaction.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "Command", Command)


@dataclass(eq=False, repr=False)
class CommandArgumentError(betterproto2.Message):
    """
    An error with an argument to a command.
    """

    argument: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_UINT32, optional=True
    )
    """
    Position of the problematic argument.
    """

    kind: "CommandArgumentErrorCommandArgumentErrorKind | None" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, optional=True
    )

    index_error: "IndexError | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "CommandArgumentError", CommandArgumentError
)


@dataclass(eq=False, repr=False)
class CommandOutput(betterproto2.Message):
    argument: "Argument | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    value: "Bcs | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    json: "___google__protobuf__.Value | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    JSON rendering of the output.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "CommandOutput", CommandOutput)


@dataclass(eq=False, repr=False)
class CommandResult(betterproto2.Message):
    """
    An intermediate result/output from the execution of a single command
    """

    return_values: "list[CommandOutput]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )

    mutated_by_ref: "list[CommandOutput]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message("sui.rpc.v2beta2", "CommandResult", CommandResult)


@dataclass(eq=False, repr=False)
class CongestedObjects(betterproto2.Message):
    """
    Set of objects that were congested, leading to the transaction's cancellation.
    """

    objects: "list[str]" = betterproto2.field(
        1, betterproto2.TYPE_STRING, repeated=True
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "CongestedObjects", CongestedObjects
)


@dataclass(eq=False, repr=False)
class ConsensusCommitPrologue(betterproto2.Message):
    """
    Consensus commit prologue system transaction.

    This message can represent V1, V2, and V3 prologue types.
    """

    epoch: "int | None" = betterproto2.field(1, betterproto2.TYPE_UINT64, optional=True)
    """
    Epoch of the commit prologue transaction.

    Present in V1, V2, V3, V4.
    """

    round: "int | None" = betterproto2.field(2, betterproto2.TYPE_UINT64, optional=True)
    """
    Consensus round of the commit.

    Present in V1, V2, V3, V4.
    """

    commit_timestamp: "datetime.datetime | None" = betterproto2.field(
        3,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Timestamp,
        optional=True,
    )
    """
    Unix timestamp from consensus.

    Present in V1, V2, V3, V4.
    """

    consensus_commit_digest: "str | None" = betterproto2.field(
        4, betterproto2.TYPE_STRING, optional=True
    )
    """
    Digest of consensus output.

    Present in V2, V3, V4.
    """

    sub_dag_index: "int | None" = betterproto2.field(
        5, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The sub DAG index of the consensus commit. This field is populated if there
    are multiple consensus commits per round.

    Present in V3, V4.
    """

    consensus_determined_version_assignments: "ConsensusDeterminedVersionAssignments | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Stores consensus handler determined shared object version assignments.

    Present in V3, V4.
    """

    additional_state_digest: "str | None" = betterproto2.field(
        7, betterproto2.TYPE_STRING, optional=True
    )
    """
    Digest of any additional state computed by the consensus handler.
    Used to detect forking bugs as early as possible.

    Present in V4.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ConsensusCommitPrologue", ConsensusCommitPrologue
)


@dataclass(eq=False, repr=False)
class ConsensusDeterminedVersionAssignments(betterproto2.Message):
    """
    Version assignments performed by consensus.
    """

    version: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_INT32, optional=True
    )
    """
    Version of this message
    """

    canceled_transactions: "list[CanceledTransaction]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Canceled transaction version assignment.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2",
    "ConsensusDeterminedVersionAssignments",
    ConsensusDeterminedVersionAssignments,
)


@dataclass(eq=False, repr=False)
class DatatypeDescriptor(betterproto2.Message):
    """
    Describes a Move Datatype.
    """

    type_name: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    Fully qualified name of this Datatype.

    This is `<defining_id>::<module>::<name>`
    """

    defining_id: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    PackageId of the package where this Datatype is defined.

    A type's `defining_id` is the `storage_id` of the package version that first introduced or added that type.
    """

    module: "str | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True
    )
    """
    Name of the module where this Datatype is defined
    """

    name: "str | None" = betterproto2.field(4, betterproto2.TYPE_STRING, optional=True)
    """
    Name of this Datatype
    """

    abilities: "list[Ability]" = betterproto2.field(
        5, betterproto2.TYPE_ENUM, repeated=True
    )
    """
    This type's abilities
    """

    type_parameters: "list[TypeParameter]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Ability constraints and phantom status for this type's generic type parameters
    """

    kind: "DatatypeDescriptorDatatypeKind | None" = betterproto2.field(
        7, betterproto2.TYPE_ENUM, optional=True
    )
    """
    Indicates whether this datatype is a 'STRUCT' or an 'ENUM'
    """

    fields: "list[FieldDescriptor]" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Set of fields if this Datatype is a struct.

    The order of the entries is the order of how the fields are defined.
    """

    variants: "list[VariantDescriptor]" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Set of variants if this Datatype is an enum.

    The order of the entries is the order of how the variants are defined.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "DatatypeDescriptor", DatatypeDescriptor
)


@dataclass(eq=False, repr=False)
class DynamicField(betterproto2.Message):
    kind: "DynamicFieldDynamicFieldKind | None" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, optional=True
    )

    parent: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    ObjectId of this dynamic field's parent.
    """

    field_id: "str | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True
    )
    """
    ObjectId of this dynamic field.
    """

    name_type: "str | None" = betterproto2.field(
        4, betterproto2.TYPE_STRING, optional=True
    )
    """
    The type of the dynamic field "name"
    """

    name_value: "bytes | None" = betterproto2.field(
        5, betterproto2.TYPE_BYTES, optional=True
    )
    """
    The serialized move value of "name"
    """

    value_type: "str | None" = betterproto2.field(
        6, betterproto2.TYPE_STRING, optional=True
    )
    """
    The type of the dynamic field "value".

    If this is a dynamic object field then this is the type of the object
    itself (which is a child of this field), otherwise this is the type of the
    value of this field.
    """

    dynamic_object_id: "str | None" = betterproto2.field(
        7, betterproto2.TYPE_STRING, optional=True
    )
    """
    The ObjectId of the child object when a child is a dynamic
    object field.

    The presence or absence of this field can be used to determine if a child
    is a dynamic field or a dynamic child object
    """

    object: "Object | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The object itself when a child is a dynamic object field.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "DynamicField", DynamicField)


@dataclass(eq=False, repr=False)
class EndOfEpochData(betterproto2.Message):
    """
    Data, which when included in a `CheckpointSummary`, signals the end of an `Epoch`.
    """

    next_epoch_committee: "list[ValidatorCommitteeMember]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The set of validators that will be in the `ValidatorCommittee` for the next epoch.
    """

    next_epoch_protocol_version: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The protocol version that is in effect during the next epoch.
    """

    epoch_commitments: "list[CheckpointCommitment]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Commitments to epoch specific state (live object set)
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "EndOfEpochData", EndOfEpochData
)


@dataclass(eq=False, repr=False)
class EndOfEpochTransaction(betterproto2.Message):
    """
    Set of operations run at the end of the epoch to close out the current epoch
    and start the next one.
    """

    transactions: "list[EndOfEpochTransactionKind]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "EndOfEpochTransaction", EndOfEpochTransaction
)


@dataclass(eq=False, repr=False)
class EndOfEpochTransactionKind(betterproto2.Message):
    """
    Operation run at the end of an epoch.

    Oneofs:
        - kind:
    """

    change_epoch: "ChangeEpoch | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    End the epoch and start the next one.
    """

    authenticator_state_expire: "AuthenticatorStateExpire | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    Expire JWKs used for zklogin.
    """

    execution_time_observations: "ExecutionTimeObservations | None" = (
        betterproto2.field(4, betterproto2.TYPE_MESSAGE, optional=True, group="kind")
    )
    """
    Execution time observations from the committee to preserve cross epoch
    """

    authenticator_state_create: "___google__protobuf__.Empty | None" = (
        betterproto2.field(200, betterproto2.TYPE_MESSAGE, optional=True, group="kind")
    )
    """
    Use higher field numbers for kinds which happen infrequently.

    Create and initialize the authenticator object used for zklogin.
    """

    randomness_state_create: "___google__protobuf__.Empty | None" = betterproto2.field(
        201, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    Create and initialize the randomness object.
    """

    deny_list_state_create: "___google__protobuf__.Empty | None" = betterproto2.field(
        202, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    Create and initialize the deny list object.
    """

    bridge_state_create: "str | None" = betterproto2.field(
        203, betterproto2.TYPE_STRING, optional=True, group="kind"
    )
    """
    Create and initialize the bridge object.
    """

    bridge_committee_init: "int | None" = betterproto2.field(
        204, betterproto2.TYPE_UINT64, optional=True, group="kind"
    )
    """
    Initialize the bridge committee.
    """

    accumulator_root_create: "___google__protobuf__.Empty | None" = betterproto2.field(
        205, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    Create the accumulator root object.
    """

    coin_registry_create: "___google__protobuf__.Empty | None" = betterproto2.field(
        206, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    Create and initialize the Coin Registry object.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "EndOfEpochTransactionKind", EndOfEpochTransactionKind
)


@dataclass(eq=False, repr=False)
class Epoch(betterproto2.Message):
    epoch: "int | None" = betterproto2.field(1, betterproto2.TYPE_UINT64, optional=True)

    committee: "ValidatorCommittee | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The committee governing this epoch.
    """

    system_state: "SystemState | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Snapshot of Sui's SystemState (`0x3::sui_system::SystemState`) at the
    beginning of the epoch, for past epochs, or the current state for the
    current epoch.
    """

    first_checkpoint: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT64, optional=True
    )

    last_checkpoint: "int | None" = betterproto2.field(
        5, betterproto2.TYPE_UINT64, optional=True
    )

    start: "datetime.datetime | None" = betterproto2.field(
        6,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Timestamp,
        optional=True,
    )

    end: "datetime.datetime | None" = betterproto2.field(
        7,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Timestamp,
        optional=True,
    )

    reference_gas_price: "int | None" = betterproto2.field(
        8, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Reference gas price denominated in MIST
    """

    protocol_config: "ProtocolConfig | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("sui.rpc.v2beta2", "Epoch", Epoch)


@dataclass(eq=False, repr=False)
class Event(betterproto2.Message):
    """
    An event.
    """

    package_id: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    Package ID of the top-level function invoked by a `MoveCall` command that triggered this
    event to be emitted.
    """

    module: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    Module name of the top-level function invoked by a `MoveCall` command that triggered this
    event to be emitted.
    """

    sender: "str | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True
    )
    """
    Address of the account that sent the transaction where this event was emitted.
    """

    event_type: "str | None" = betterproto2.field(
        4, betterproto2.TYPE_STRING, optional=True
    )
    """
    The type of the event emitted.
    """

    contents: "Bcs | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    BCS serialized bytes of the event.
    """

    json: "___google__protobuf__.Value | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    JSON rendering of the event.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "Event", Event)


@dataclass(eq=False, repr=False)
class ExecutedTransaction(betterproto2.Message):
    digest: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    The digest of this Transaction.
    """

    transaction: "Transaction | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The transaction itself.
    """

    signatures: "list[UserSignature]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of user signatures that are used to authorize the
    execution of this transaction.
    """

    effects: "TransactionEffects | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The `TransactionEffects` for this transaction.
    """

    events: "TransactionEvents | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The `TransactionEvents` for this transaction.

    This field might be empty, even if it was explicitly requested, if the
    transaction didn't produce any events.
    `sui.types.TransactionEffects.events_digest` is populated if the
    transaction produced any events.
    """

    checkpoint: "int | None" = betterproto2.field(
        6, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The sequence number for the checkpoint that includes this transaction.
    """

    timestamp: "datetime.datetime | None" = betterproto2.field(
        7,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Timestamp,
        optional=True,
    )
    """
    The Unix timestamp of the checkpoint that includes this transaction.
    """

    balance_changes: "list[BalanceChange]" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, repeated=True
    )

    input_objects: "list[Object]" = betterproto2.field(
        10, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Set of input objects used during the execution of this transaction.
    """

    output_objects: "list[Object]" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Set of output objects produced from the execution of this transaction.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ExecutedTransaction", ExecutedTransaction
)


@dataclass(eq=False, repr=False)
class ExecuteTransactionRequest(betterproto2.Message):
    transaction: "Transaction | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The transaction to execute.
    """

    signatures: "list[UserSignature]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Set of `UserSiganture`s authorizing the execution of the provided
    transaction.
    """

    read_mask: "___google__protobuf__.FieldMask | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Mask specifying which fields to read.
    If no mask is specified, defaults to `finality`.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ExecuteTransactionRequest", ExecuteTransactionRequest
)


@dataclass(eq=False, repr=False)
class ExecuteTransactionResponse(betterproto2.Message):
    """
    Response message for `NodeService.ExecuteTransaction`.
    """

    finality: "TransactionFinality | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Indicates the finality of the executed transaction.
    """

    transaction: "ExecutedTransaction | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ExecuteTransactionResponse", ExecuteTransactionResponse
)


@dataclass(eq=False, repr=False)
class ExecutionError(betterproto2.Message):
    """
    An error that can occur during the execution of a transaction.

    Oneofs:
        - error_details:
    """

    description: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    A human readable description of the error
    """

    command: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The command, if any, during which the error occurred.
    """

    kind: "ExecutionErrorExecutionErrorKind | None" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, optional=True
    )

    abort: "MoveAbort | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="error_details"
    )

    size_error: "SizeError | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="error_details"
    )

    command_argument_error: "CommandArgumentError | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="error_details"
    )

    type_argument_error: "TypeArgumentError | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True, group="error_details"
    )

    package_upgrade_error: "PackageUpgradeError | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True, group="error_details"
    )

    index_error: "IndexError | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True, group="error_details"
    )

    object_id: "str | None" = betterproto2.field(
        10, betterproto2.TYPE_STRING, optional=True, group="error_details"
    )

    coin_deny_list_error: "CoinDenyListError | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True, group="error_details"
    )

    congested_objects: "CongestedObjects | None" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, optional=True, group="error_details"
    )
    """
    Set of objects that were congested, leading to the transaction's cancellation.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ExecutionError", ExecutionError
)


@dataclass(eq=False, repr=False)
class ExecutionStatus(betterproto2.Message):
    """
    The status of an executed transaction.
    """

    success: "bool | None" = betterproto2.field(
        1, betterproto2.TYPE_BOOL, optional=True
    )
    """
    Indicates if the transaction was successful or not.
    """

    error: "ExecutionError | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The error if `success` is false.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ExecutionStatus", ExecutionStatus
)


@dataclass(eq=False, repr=False)
class ExecutionTimeObservation(betterproto2.Message):
    kind: "ExecutionTimeObservationExecutionTimeObservationKind | None" = (
        betterproto2.field(1, betterproto2.TYPE_ENUM, optional=True)
    )

    move_entry_point: "MoveCall | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    validator_observations: "list[ValidatorExecutionTimeObservation]" = (
        betterproto2.field(3, betterproto2.TYPE_MESSAGE, repeated=True)
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ExecutionTimeObservation", ExecutionTimeObservation
)


@dataclass(eq=False, repr=False)
class ExecutionTimeObservations(betterproto2.Message):
    version: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_INT32, optional=True
    )
    """
    Version of this ExecutionTimeObservations
    """

    observations: "list[ExecutionTimeObservation]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ExecutionTimeObservations", ExecutionTimeObservations
)


@dataclass(eq=False, repr=False)
class FieldDescriptor(betterproto2.Message):
    """
    Descriptor of a field that belongs to a struct or enum variant
    """

    name: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    Name of the field
    """

    position: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT32, optional=True
    )
    """
    Order or position of the field in the struct or enum variant definition.
    """

    type: "OpenSignatureBody | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The type of the field
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "FieldDescriptor", FieldDescriptor
)


@dataclass(eq=False, repr=False)
class FunctionDescriptor(betterproto2.Message):
    """
    Descriptor of a Move function
    """

    name: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    Name of the function
    """

    visibility: "FunctionDescriptorVisibility | None" = betterproto2.field(
        5, betterproto2.TYPE_ENUM, optional=True
    )
    """
    Whether the function is `public`, `private` or `public(friend)`
    """

    is_entry: "bool | None" = betterproto2.field(
        6, betterproto2.TYPE_BOOL, optional=True
    )
    """
    Whether the function is marked `entry` or not.
    """

    type_parameters: "list[TypeParameter]" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Ability constraints for type parameters
    """

    parameters: "list[OpenSignature]" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Formal parameter types.
    """

    returns: "list[OpenSignature]" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Return types.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "FunctionDescriptor", FunctionDescriptor
)


@dataclass(eq=False, repr=False)
class GasCostSummary(betterproto2.Message):
    """
    Summary of gas charges.
    """

    computation_cost: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Cost of computation/execution.
    """

    storage_cost: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Storage cost, it's the sum of all storage cost for all objects created or mutated.
    """

    storage_rebate: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The amount of storage cost refunded to the user for all objects deleted or mutated in the
    transaction.
    """

    non_refundable_storage_fee: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The fee for the rebate. The portion of the storage rebate kept by the system.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GasCostSummary", GasCostSummary
)


@dataclass(eq=False, repr=False)
class GasPayment(betterproto2.Message):
    """
    Payment information for executing a transaction.
    """

    objects: "list[ObjectReference]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Set of gas objects to use for payment.
    """

    owner: "str | None" = betterproto2.field(2, betterproto2.TYPE_STRING, optional=True)
    """
    Owner of the gas objects, either the transaction sender or a sponsor.
    """

    price: "int | None" = betterproto2.field(3, betterproto2.TYPE_UINT64, optional=True)
    """
    Gas unit price to use when charging for computation.

    Must be greater than or equal to the network's current RGP (reference gas price).
    """

    budget: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Total budget willing to spend for the execution of a transaction.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "GasPayment", GasPayment)


@dataclass(eq=False, repr=False)
class GenesisTransaction(betterproto2.Message):
    """
    The genesis transaction.
    """

    objects: "list[Object]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Set of genesis objects.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GenesisTransaction", GenesisTransaction
)


@dataclass(eq=False, repr=False)
class GetBalanceRequest(betterproto2.Message):
    """
    Request message for `LiveDataService.GetBalance`.
    """

    owner: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    Required. The owner's Sui address.
    """

    coin_type: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    Required. The type names for the coin (e.g., 0x2::sui::SUI).
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetBalanceRequest", GetBalanceRequest
)


@dataclass(eq=False, repr=False)
class GetBalanceResponse(betterproto2.Message):
    """
    Response message for `LiveDataService.GetBalance`.
    Return the total coin balance for one coin type, owned by the address owner.
    """

    balance: "Balance | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The balance information for the requested coin type.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetBalanceResponse", GetBalanceResponse
)


@dataclass(eq=False, repr=False)
class GetCheckpointRequest(betterproto2.Message):
    """


    Oneofs:
        - checkpoint_id: If neither is provided, return the latest
    """

    sequence_number: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_UINT64, optional=True, group="checkpoint_id"
    )
    """
    The sequence number of the requested checkpoint.
    """

    digest: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True, group="checkpoint_id"
    )
    """
    The digest of the requested checkpoint.
    """

    read_mask: "___google__protobuf__.FieldMask | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Mask specifying which fields to read.
    If no mask is specified, defaults to `object_id,version,digest`.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetCheckpointRequest", GetCheckpointRequest
)


@dataclass(eq=False, repr=False)
class GetCheckpointResponse(betterproto2.Message):
    checkpoint: "Checkpoint | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetCheckpointResponse", GetCheckpointResponse
)


@dataclass(eq=False, repr=False)
class GetCoinInfoRequest(betterproto2.Message):
    """
    Request message for `NodeService.GetCoinInfo`.
    """

    coin_type: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    The coin type to request information about
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetCoinInfoRequest", GetCoinInfoRequest
)


@dataclass(eq=False, repr=False)
class GetCoinInfoResponse(betterproto2.Message):
    """
    Response message for `NodeService.GetCoinInfo`.
    """

    coin_type: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    Required. The coin type.
    """

    metadata: "CoinMetadata | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    This field will be populated with information about this coin
    type's `0x2::coin::CoinMetadata` if it exists and has not been wrapped.
    """

    treasury: "CoinTreasury | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    This field will be populated with information about this coin
    type's `0x2::coin::TreasuryCap` if it exists and has not been wrapped.
    """

    regulated_metadata: "RegulatedCoinMetadata | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    If this coin type is a regulated coin, this field will be
    populated with information about its `0x2::coin::RegulatedCoinMetadata`
    object.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetCoinInfoResponse", GetCoinInfoResponse
)


@dataclass(eq=False, repr=False)
class GetDatatypeRequest(betterproto2.Message):
    package_id: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    Required. The `storage_id` of the requested package.
    """

    module_name: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    Required. The name of the requested module.
    """

    name: "str | None" = betterproto2.field(3, betterproto2.TYPE_STRING, optional=True)
    """
    Required. The name of the requested datatype.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetDatatypeRequest", GetDatatypeRequest
)


@dataclass(eq=False, repr=False)
class GetDatatypeResponse(betterproto2.Message):
    datatype: "DatatypeDescriptor | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The datatype.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetDatatypeResponse", GetDatatypeResponse
)


@dataclass(eq=False, repr=False)
class GetEpochRequest(betterproto2.Message):
    epoch: "int | None" = betterproto2.field(1, betterproto2.TYPE_UINT64, optional=True)
    """
    The requested epoch.
    If no epoch is provided the current epoch will be returned.
    """

    read_mask: "___google__protobuf__.FieldMask | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Mask specifying which fields to read.
    If no mask is specified, defaults to `epoch`.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetEpochRequest", GetEpochRequest
)


@dataclass(eq=False, repr=False)
class GetEpochResponse(betterproto2.Message):
    epoch: "Epoch | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetEpochResponse", GetEpochResponse
)


@dataclass(eq=False, repr=False)
class GetFunctionRequest(betterproto2.Message):
    package_id: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    Required. The `storage_id` of the requested package.
    """

    module_name: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    Required. The name of the requested module.
    """

    name: "str | None" = betterproto2.field(3, betterproto2.TYPE_STRING, optional=True)
    """
    Required. The name of the requested function.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetFunctionRequest", GetFunctionRequest
)


@dataclass(eq=False, repr=False)
class GetFunctionResponse(betterproto2.Message):
    function: "FunctionDescriptor | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The function.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetFunctionResponse", GetFunctionResponse
)


@dataclass(eq=False, repr=False)
class GetObjectRequest(betterproto2.Message):
    object_id: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    Required. The `ObjectId` of the requested object.
    """

    version: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Request a specific version of the object.
    If no version is specified, and the object is live, then the latest
    version of the object is returned.
    """

    read_mask: "___google__protobuf__.FieldMask | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Mask specifying which fields to read.
    If no mask is specified, defaults to `object_id,version,digest`.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetObjectRequest", GetObjectRequest
)


@dataclass(eq=False, repr=False)
class GetObjectResponse(betterproto2.Message):
    object: "Object | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetObjectResponse", GetObjectResponse
)


@dataclass(eq=False, repr=False)
class GetObjectResult(betterproto2.Message):
    """


    Oneofs:
        - result:
    """

    object: "Object | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="result"
    )

    error: "___google__rpc__.Status | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="result"
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetObjectResult", GetObjectResult
)


@dataclass(eq=False, repr=False)
class GetPackageRequest(betterproto2.Message):
    package_id: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    Required. The `storage_id` of the requested package.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetPackageRequest", GetPackageRequest
)


@dataclass(eq=False, repr=False)
class GetPackageResponse(betterproto2.Message):
    package: "Package | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The package.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetPackageResponse", GetPackageResponse
)


@dataclass(eq=False, repr=False)
class GetServiceInfoRequest(betterproto2.Message):
    pass


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetServiceInfoRequest", GetServiceInfoRequest
)


@dataclass(eq=False, repr=False)
class GetServiceInfoResponse(betterproto2.Message):
    chain_id: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    The chain identifier of the chain that this node is on.

    The chain identifier is the digest of the genesis checkpoint, the
    checkpoint with sequence number 0.
    """

    chain: "str | None" = betterproto2.field(2, betterproto2.TYPE_STRING, optional=True)
    """
    Human-readable name of the chain that this node is on.

    This is intended to be a human-readable name like `mainnet`, `testnet`, and so on.
    """

    epoch: "int | None" = betterproto2.field(3, betterproto2.TYPE_UINT64, optional=True)
    """
    Current epoch of the node based on its highest executed checkpoint.
    """

    checkpoint_height: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Checkpoint height of the most recently executed checkpoint.
    """

    timestamp: "datetime.datetime | None" = betterproto2.field(
        5,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Timestamp,
        optional=True,
    )
    """
    Unix timestamp of the most recently executed checkpoint.
    """

    lowest_available_checkpoint: "int | None" = betterproto2.field(
        6, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The lowest checkpoint for which checkpoints and transaction data are available.
    """

    lowest_available_checkpoint_objects: "int | None" = betterproto2.field(
        7, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The lowest checkpoint for which object data is available.
    """

    server: "str | None" = betterproto2.field(
        8, betterproto2.TYPE_STRING, optional=True
    )
    """
    Software version of the service. Similar to the `server` http header.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetServiceInfoResponse", GetServiceInfoResponse
)


@dataclass(eq=False, repr=False)
class GetTransactionRequest(betterproto2.Message):
    digest: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    Required. The digest of the requested transaction.
    """

    read_mask: "___google__protobuf__.FieldMask | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Mask specifying which fields to read.
    If no mask is specified, defaults to `digest`.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetTransactionRequest", GetTransactionRequest
)


@dataclass(eq=False, repr=False)
class GetTransactionResponse(betterproto2.Message):
    transaction: "ExecutedTransaction | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetTransactionResponse", GetTransactionResponse
)


@dataclass(eq=False, repr=False)
class GetTransactionResult(betterproto2.Message):
    """


    Oneofs:
        - result:
    """

    transaction: "ExecutedTransaction | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="result"
    )

    error: "___google__rpc__.Status | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="result"
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "GetTransactionResult", GetTransactionResult
)


@dataclass(eq=False, repr=False)
class IndexError(betterproto2.Message):
    index: "int | None" = betterproto2.field(1, betterproto2.TYPE_UINT32, optional=True)
    """
    Index of an input or result.
    """

    subresult: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT32, optional=True
    )
    """
    Index of a subresult.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "IndexError", IndexError)


@dataclass(eq=False, repr=False)
class Input(betterproto2.Message):
    """
    An input to a user transaction.
    """

    kind: "InputInputKind | None" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, optional=True
    )

    pure: "bytes | None" = betterproto2.field(2, betterproto2.TYPE_BYTES, optional=True)
    """
    A move value serialized as BCS.

    For normal operations this is required to be a move primitive type and not contain structs
    or objects.
    """

    object_id: "str | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True
    )
    """
    `ObjectId` of the object input.
    """

    version: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Requested version of the input object when `kind` is `IMMUTABLE_OR_OWNED`
    or `RECEIVING` or if `kind` is `SHARED` this is the initial version of the
    object when it was shared
    """

    digest: "str | None" = betterproto2.field(
        5, betterproto2.TYPE_STRING, optional=True
    )
    """
    The digest of this object.
    """

    mutable: "bool | None" = betterproto2.field(
        6, betterproto2.TYPE_BOOL, optional=True
    )
    """
    Controls whether the caller asks for a mutable reference to the shared
    object.
    """

    literal: "___google__protobuf__.Value | None" = betterproto2.field(
        1000, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    A literal value

    INPUT ONLY
    """


default_message_pool.register_message("sui.rpc.v2beta2", "Input", Input)


@dataclass(eq=False, repr=False)
class Jwk(betterproto2.Message):
    """
    A JSON web key.

    Struct that contains info for a JWK. A list of them for different kinds can
    be retrieved from the JWK endpoint (for example, <https://www.googleapis.com/oauth2/v3/certs>).
    The JWK is used to verify the JWT token.
    """

    kty: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    Key type parameter, https://datatracker.ietf.org/doc/html/rfc7517#section-4.1.
    """

    e: "str | None" = betterproto2.field(2, betterproto2.TYPE_STRING, optional=True)
    """
    RSA public exponent, https://datatracker.ietf.org/doc/html/rfc7517#section-9.3.
    """

    n: "str | None" = betterproto2.field(3, betterproto2.TYPE_STRING, optional=True)
    """
    RSA modulus, https://datatracker.ietf.org/doc/html/rfc7517#section-9.3.
    """

    alg: "str | None" = betterproto2.field(4, betterproto2.TYPE_STRING, optional=True)
    """
    Algorithm parameter, https://datatracker.ietf.org/doc/html/rfc7517#section-4.4.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "Jwk", Jwk)


@dataclass(eq=False, repr=False)
class JwkId(betterproto2.Message):
    """
    Key to uniquely identify a JWK.
    """

    iss: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    The issuer or identity of the OIDC provider.
    """

    kid: "str | None" = betterproto2.field(2, betterproto2.TYPE_STRING, optional=True)
    """
    A key ID used to uniquely identify a key from an OIDC provider.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "JwkId", JwkId)


@dataclass(eq=False, repr=False)
class Linkage(betterproto2.Message):
    """
    Upgraded package info for the linkage table.
    """

    original_id: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    Id of the original package.
    """

    upgraded_id: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    Id of the upgraded package.
    """

    upgraded_version: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Version of the upgraded package.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "Linkage", Linkage)


@dataclass(eq=False, repr=False)
class ListBalancesRequest(betterproto2.Message):
    """
    Request message for `LiveDataService.ListBalances`.
    """

    owner: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    Required. The owner's Sui address.
    """

    page_size: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT32, optional=True
    )
    """
    The maximum number of balance entries to return. The service may return fewer than this value.
    If unspecified, at most `50` entries will be returned.
    The maximum value is `1000`; values above `1000` will be coerced to `1000`.
    """

    page_token: "bytes | None" = betterproto2.field(
        3, betterproto2.TYPE_BYTES, optional=True
    )
    """
    A page token, received from a previous `ListBalances` call.
    Provide this to retrieve the subsequent page.

    When paginating, all other parameters provided to `ListBalances` must
    match the call that provided the page token.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ListBalancesRequest", ListBalancesRequest
)


@dataclass(eq=False, repr=False)
class ListBalancesResponse(betterproto2.Message):
    """
    Response message for `LiveDataService.ListBalances`.
    Return the total coin balance for all coin types, owned by the address owner.
    """

    balances: "list[Balance]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The list of coin types and their respective balances.
    """

    next_page_token: "bytes | None" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, optional=True
    )
    """
    A token, which can be sent as `page_token` to retrieve the next page.
    If this field is omitted, there are no subsequent pages.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ListBalancesResponse", ListBalancesResponse
)


@dataclass(eq=False, repr=False)
class ListDynamicFieldsRequest(betterproto2.Message):
    """
    Request message for `NodeService.ListDynamicFields`
    """

    parent: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    Required. The `UID` of the parent, which owns the collections of dynamic fields.
    """

    page_size: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT32, optional=True
    )
    """
    The maximum number of dynamic fields to return. The service may return fewer than this value.
    If unspecified, at most `50` entries will be returned.
    The maximum value is `1000`; values above `1000` will be coerced to `1000`.
    """

    page_token: "bytes | None" = betterproto2.field(
        3, betterproto2.TYPE_BYTES, optional=True
    )
    """
    A page token, received from a previous `ListDynamicFields` call.
    Provide this to retrieve the subsequent page.

    When paginating, all other parameters provided to `ListDynamicFields` must
    match the call that provided the page token.
    """

    read_mask: "___google__protobuf__.FieldMask | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ListDynamicFieldsRequest", ListDynamicFieldsRequest
)


@dataclass(eq=False, repr=False)
class ListDynamicFieldsResponse(betterproto2.Message):
    """
    Response message for `NodeService.ListDynamicFields`
    """

    dynamic_fields: "list[DynamicField]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Page of dynamic fields owned by the specified parent.
    """

    next_page_token: "bytes | None" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, optional=True
    )
    """
    A token, which can be sent as `page_token` to retrieve the next page.
    If this field is omitted, there are no subsequent pages.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ListDynamicFieldsResponse", ListDynamicFieldsResponse
)


@dataclass(eq=False, repr=False)
class ListOwnedObjectsRequest(betterproto2.Message):
    owner: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    Required. The address of the account that owns the objects.
    """

    page_size: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT32, optional=True
    )
    """
    The maximum number of entries return. The service may return fewer than this value.
    If unspecified, at most `50` entries will be returned.
    The maximum value is `1000`; values above `1000` will be coerced to `1000`.
    """

    page_token: "bytes | None" = betterproto2.field(
        3, betterproto2.TYPE_BYTES, optional=True
    )
    """
    A page token, received from a previous `ListOwnedObjects` call.
    Provide this to retrieve the subsequent page.

    When paginating, all other parameters provided to `ListOwnedObjects` must
    match the call that provided the page token.
    """

    read_mask: "___google__protobuf__.FieldMask | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )

    object_type: "str | None" = betterproto2.field(
        5, betterproto2.TYPE_STRING, optional=True
    )
    """
    Optional type filter to limit the types of objects listed.

    Providing an object type with no type params will return objects of that
    type with any type parameter, e.g. `0x2::coin::Coin` will return all
    `Coin<T>` objects regardless of the type parameter `T`. Providing a type
    with a type param will retrict the returned objects to only those objects
    that match the provided type parameters, e.g.
    `0x2::coin::Coin<0x2::sui::SUI>` will only return `Coin<SUI>` objects.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ListOwnedObjectsRequest", ListOwnedObjectsRequest
)


@dataclass(eq=False, repr=False)
class ListOwnedObjectsResponse(betterproto2.Message):
    objects: "list[Object]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Page of dynamic fields owned by the specified parent.
    """

    next_page_token: "bytes | None" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, optional=True
    )
    """
    A token, which can be sent as `page_token` to retrieve the next page.
    If this field is omitted, there are no subsequent pages.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ListOwnedObjectsResponse", ListOwnedObjectsResponse
)


@dataclass(eq=False, repr=False)
class ListPackageVersionsRequest(betterproto2.Message):
    package_id: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    Required. The `storage_id` of any version of the package.
    """

    page_size: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT32, optional=True
    )
    """
    The maximum number of versions to return. The service may return fewer than this value.
    If unspecified, at most `1000` entries will be returned.
    The maximum value is `10000`; values above `10000` will be coerced to `10000`.
    """

    page_token: "bytes | None" = betterproto2.field(
        3, betterproto2.TYPE_BYTES, optional=True
    )
    """
    A page token, received from a previous `ListPackageVersions` call.
    Provide this to retrieve the subsequent page.

    When paginating, all other parameters provided to `ListPackageVersions` must
    match the call that provided the page token.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ListPackageVersionsRequest", ListPackageVersionsRequest
)


@dataclass(eq=False, repr=False)
class ListPackageVersionsResponse(betterproto2.Message):
    versions: "list[PackageVersion]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of all package versions, ordered by version.
    """

    next_page_token: "bytes | None" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, optional=True
    )
    """
    A token, which can be sent as `page_token` to retrieve the next page.
    If this field is omitted, there are no subsequent pages.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ListPackageVersionsResponse", ListPackageVersionsResponse
)


@dataclass(eq=False, repr=False)
class MakeMoveVector(betterproto2.Message):
    """
    Command to build a Move vector out of a set of individual elements.
    """

    element_type: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    Type of the individual elements.

    This is required to be set when the type can't be inferred, for example when the set of
    provided arguments are all pure input values.
    """

    elements: "list[Argument]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The set individual elements to build the vector with.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "MakeMoveVector", MakeMoveVector
)


@dataclass(eq=False, repr=False)
class MergeCoins(betterproto2.Message):
    """
    Command to merge multiple coins of the same type into a single coin.
    """

    coin: "Argument | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Coin to merge coins into.
    """

    coins_to_merge: "list[Argument]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Set of coins to merge into `coin`.

    All listed coins must be of the same type and be the same type as `coin`
    """


default_message_pool.register_message("sui.rpc.v2beta2", "MergeCoins", MergeCoins)


@dataclass(eq=False, repr=False)
class Module(betterproto2.Message):
    """
    A Move Module.
    """

    name: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    Name of this module.
    """

    contents: "bytes | None" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, optional=True
    )
    """
    Serialized bytecode of the module.
    """

    datatypes: "list[DatatypeDescriptor]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of DataTypes defined by this module.
    """

    functions: "list[FunctionDescriptor]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of Functions defined by this module.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "Module", Module)


@dataclass(eq=False, repr=False)
class MoveAbort(betterproto2.Message):
    abort_code: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_UINT64, optional=True
    )

    location: "MoveLocation | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Location in Move where the error occurred.
    """

    clever_error: "CleverError | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Extra error information if abort code is a "Clever Error"
    """


default_message_pool.register_message("sui.rpc.v2beta2", "MoveAbort", MoveAbort)


@dataclass(eq=False, repr=False)
class MoveCall(betterproto2.Message):
    """
    Command to call a Move function.

    Functions that can be called by a `MoveCall` command are those that have a function signature
    that is either `entry` or `public` (which don't have a reference return type).
    """

    package: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    The package containing the module and function.
    """

    module: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    The specific module in the package containing the function.
    """

    function: "str | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True
    )
    """
    The function to be called.
    """

    type_arguments: "list[str]" = betterproto2.field(
        4, betterproto2.TYPE_STRING, repeated=True
    )
    """
    The type arguments to the function.
    """

    arguments: "list[Argument]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The arguments to the function.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "MoveCall", MoveCall)


@dataclass(eq=False, repr=False)
class MoveLocation(betterproto2.Message):
    """
    Location in Move bytecode where an error occurred.
    """

    package: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    The package ID.
    """

    module: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    The module name.
    """

    function: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT32, optional=True
    )
    """
    The function index.
    """

    instruction: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT32, optional=True
    )
    """
    Offset of the instruction where the error occurred.
    """

    function_name: "str | None" = betterproto2.field(
        5, betterproto2.TYPE_STRING, optional=True
    )
    """
    The name of the function, if available.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "MoveLocation", MoveLocation)


@dataclass(eq=False, repr=False)
class MoveTable(betterproto2.Message):
    """
    A message that represents a Move `0x2::table::Table` or `0x2::bag::Bag`
    """

    id: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    The UID of the table or bag
    """

    size: "int | None" = betterproto2.field(2, betterproto2.TYPE_UINT64, optional=True)
    """
    The size or number of key-value pairs in the table or bag
    """


default_message_pool.register_message("sui.rpc.v2beta2", "MoveTable", MoveTable)


@dataclass(eq=False, repr=False)
class MultisigAggregatedSignature(betterproto2.Message):
    """
    Aggregated signature from members of a multisig committee.
    """

    signatures: "list[MultisigMemberSignature]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The plain signatures encoded with signature scheme.

    The signatures must be in the same order as they are listed in the committee.
    """

    bitmap: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT32, optional=True
    )
    """
    Bitmap indicating which committee members contributed to the
    signature.
    """

    legacy_bitmap: "list[int]" = betterproto2.field(
        3, betterproto2.TYPE_UINT32, repeated=True
    )
    """
    If present, means this signature's on-chain format uses the old
    legacy multisig format.
    """

    committee: "MultisigCommittee | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The committee to use to validate this signature.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "MultisigAggregatedSignature", MultisigAggregatedSignature
)


@dataclass(eq=False, repr=False)
class MultisigCommittee(betterproto2.Message):
    """
    A multisig committee.
    """

    members: "list[MultisigMember]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of committee members and their corresponding weight.
    """

    threshold: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT32, optional=True
    )
    """
    The threshold of signatures needed to validate a signature from
    this committee.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "MultisigCommittee", MultisigCommittee
)


@dataclass(eq=False, repr=False)
class MultisigMember(betterproto2.Message):
    """
    A member in a multisig committee.
    """

    public_key: "MultisigMemberPublicKey | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The public key of the committee member.
    """

    weight: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT32, optional=True
    )
    """
    The weight of this member's signature.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "MultisigMember", MultisigMember
)


@dataclass(eq=False, repr=False)
class MultisigMemberPublicKey(betterproto2.Message):
    """
    Set of valid public keys for multisig committee members.
    """

    scheme: "SignatureScheme | None" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, optional=True
    )
    """
    The signature scheme of this public key.
    """

    public_key: "bytes | None" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, optional=True
    )
    """
    Public key bytes if scheme is ed25519 | secp256k1 | secp256r1 | passkey.
    """

    zklogin: "ZkLoginPublicIdentifier | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    A zklogin public identifier if scheme is zklogin.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "MultisigMemberPublicKey", MultisigMemberPublicKey
)


@dataclass(eq=False, repr=False)
class MultisigMemberSignature(betterproto2.Message):
    """
    A signature from a member of a multisig committee.
    """

    scheme: "SignatureScheme | None" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, optional=True
    )
    """
    The signature scheme of this signature.
    """

    signature: "bytes | None" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, optional=True
    )
    """
    Signature bytes if scheme is ed25519 | secp256k1 | secp256r1.
    """

    zklogin: "ZkLoginAuthenticator | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The zklogin authenticator if scheme is `ZKLOGIN`.
    """

    passkey: "PasskeyAuthenticator | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The passkey authenticator if scheme is `PASSKEY`.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "MultisigMemberSignature", MultisigMemberSignature
)


@dataclass(eq=False, repr=False)
class Object(betterproto2.Message):
    """
    An object on the Sui blockchain.
    """

    bcs: "Bcs | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    """
    This Object serialized as BCS.
    """

    object_id: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    `ObjectId` for this object.
    """

    version: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Version of the object.
    """

    digest: "str | None" = betterproto2.field(
        4, betterproto2.TYPE_STRING, optional=True
    )
    """
    The digest of this Object.
    """

    owner: "Owner | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Owner of the object.
    """

    object_type: "str | None" = betterproto2.field(
        6, betterproto2.TYPE_STRING, optional=True
    )
    """
    The type of this object.

    This will be 'package' for packages and a StructTag for move structs.
    """

    has_public_transfer: "bool | None" = betterproto2.field(
        7, betterproto2.TYPE_BOOL, optional=True
    )
    """
    DEPRECATED this field is no longer used to determine whether a tx can transfer this
    object. Instead, it is always calculated from the objects type when loaded in execution.

    Only set for Move structs
    """

    contents: "Bcs | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    BCS bytes of a Move struct value.

    Only set for Move structs
    """

    package: "Package | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Package information for Move Packages
    """

    previous_transaction: "str | None" = betterproto2.field(
        10, betterproto2.TYPE_STRING, optional=True
    )
    """
    The digest of the transaction that created or last mutated this object
    """

    storage_rebate: "int | None" = betterproto2.field(
        11, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The amount of SUI to rebate if this object gets deleted.
    This number is re-calculated each time the object is mutated based on
    the present storage gas price.
    """

    json: "___google__protobuf__.Value | None" = betterproto2.field(
        100, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    JSON rendering of the object.
    """

    balance: "int | None" = betterproto2.field(
        101, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Current balance if this object is a `0x2::coin::Coin<T>`
    """


default_message_pool.register_message("sui.rpc.v2beta2", "Object", Object)


@dataclass(eq=False, repr=False)
class ObjectReference(betterproto2.Message):
    """
    Reference to an object.
    """

    object_id: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    The object id of this object.
    """

    version: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The version of this object.
    """

    digest: "str | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True
    )
    """
    The digest of this object.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ObjectReference", ObjectReference
)


@dataclass(eq=False, repr=False)
class OpenSignature(betterproto2.Message):
    """
    Representation of a type signature that could appear as a function parameter or return value.
    """

    reference: "OpenSignatureReference | None" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, optional=True
    )

    body: "OpenSignatureBody | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("sui.rpc.v2beta2", "OpenSignature", OpenSignature)


@dataclass(eq=False, repr=False)
class OpenSignatureBody(betterproto2.Message):
    """
    Representation of a type signature that could appear as a field type for a struct or enum
    """

    type: "OpenSignatureBodyType | None" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, optional=True
    )
    """
    Type of this signature
    """

    type_name: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    Fully qualified name of the datatype when `type` is `DATATYPE`
    """

    type_parameter_instantiation: "list[OpenSignatureBody]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Set when `type` is `VECTOR` or `DATATYPE`
    """

    type_parameter: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT32, optional=True
    )
    """
    Position of the type parameter as defined in the containing data type descriptor when `type` is `TYPE_PARAMETER`
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "OpenSignatureBody", OpenSignatureBody
)


@dataclass(eq=False, repr=False)
class Owner(betterproto2.Message):
    """
    Enum of different types of ownership for an object.
    """

    kind: "OwnerOwnerKind | None" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, optional=True
    )

    address: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    Address or ObjectId of the owner
    """

    version: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The `initial_shared_version` if kind is `SHARED` or `start_version` if kind `CONSENSUS_ADDRESS`.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "Owner", Owner)


@dataclass(eq=False, repr=False)
class Package(betterproto2.Message):
    """
    A Move Package
    """

    storage_id: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    The PackageId of this package

    A package's `storage_id` is the Sui ObjectId of the package on-chain.
    Outside of system packages the `storage_id` for every package version is
    different.
    """

    original_id: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    The PackageId of the first published version of this package.

    A package's `original_id` (sometimes also called its `runtime_id`) is the
    `storage_id` of the first version of this package that has been published.
    The `original_id`/`runtime_id` is stable across all versions of the
    package and does not ever change.
    """

    version: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The version of this package
    """

    modules: "list[Module]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The modules defined by this package
    """

    type_origins: "list[TypeOrigin]" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    List of datatype origins for mapping datatypes to a package version where
    it was first defined
    """

    linkage: "list[Linkage]" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The package's transitive dependencies as a mapping from the package's
    runtime Id (the Id it is referred to by in other packages) to its
    storage Id (the Id it is loaded from on chain).
    """


default_message_pool.register_message("sui.rpc.v2beta2", "Package", Package)


@dataclass(eq=False, repr=False)
class PackageUpgradeError(betterproto2.Message):
    """
    An error with upgrading a package.
    """

    kind: "PackageUpgradeErrorPackageUpgradeErrorKind | None" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, optional=True
    )

    package_id: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    The Package Id.
    """

    digest: "str | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True
    )
    """
    A digest.
    """

    policy: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT32, optional=True
    )
    """
    The policy.
    """

    ticket_id: "str | None" = betterproto2.field(
        5, betterproto2.TYPE_STRING, optional=True
    )
    """
    The ticket Id.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "PackageUpgradeError", PackageUpgradeError
)


@dataclass(eq=False, repr=False)
class PackageVersion(betterproto2.Message):
    """
    A simplified representation of a package version
    """

    package_id: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    The storage ID of this package version
    """

    version: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The version number
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "PackageVersion", PackageVersion
)


@dataclass(eq=False, repr=False)
class PasskeyAuthenticator(betterproto2.Message):
    """
    A passkey authenticator.

    See
    [struct.PasskeyAuthenticator](https://mystenlabs.github.io/sui-rust-sdk/sui_sdk_types/struct.PasskeyAuthenticator.html#bcs)
    for more information on the requirements on the shape of the
    `client_data_json` field.
    """

    authenticator_data: "bytes | None" = betterproto2.field(
        1, betterproto2.TYPE_BYTES, optional=True
    )
    """
    Opaque authenticator data for this passkey signature.

    See [Authenticator Data](https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data) for
    more information on this field.
    """

    client_data_json: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    Structured, unparsed, JSON for this passkey signature.

    See [CollectedClientData](https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata)
    for more information on this field.
    """

    signature: "SimpleSignature | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    A secp256r1 signature.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "PasskeyAuthenticator", PasskeyAuthenticator
)


@dataclass(eq=False, repr=False)
class ProgrammableTransaction(betterproto2.Message):
    """
    A user transaction.

    Contains a series of native commands and Move calls where the results of one command can be
    used in future commands.
    """

    inputs: "list[Input]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Input objects or primitive values.
    """

    commands: "list[Command]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The commands to be executed sequentially. A failure in any command
    results in the failure of the entire transaction.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ProgrammableTransaction", ProgrammableTransaction
)


@dataclass(eq=False, repr=False)
class ProtocolConfig(betterproto2.Message):
    protocol_version: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_UINT64, optional=True
    )

    feature_flags: "dict[str, bool]" = betterproto2.field(
        2,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_BOOL
        ),
    )

    attributes: "dict[str, str]" = betterproto2.field(
        3,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_STRING
        ),
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ProtocolConfig", ProtocolConfig
)


@dataclass(eq=False, repr=False)
class Publish(betterproto2.Message):
    """
    Command to publish a new Move package.
    """

    modules: "list[bytes]" = betterproto2.field(
        1, betterproto2.TYPE_BYTES, repeated=True
    )
    """
    The serialized Move modules.
    """

    dependencies: "list[str]" = betterproto2.field(
        2, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Set of packages that the to-be published package depends on.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "Publish", Publish)


@dataclass(eq=False, repr=False)
class RandomnessStateUpdate(betterproto2.Message):
    """
    Randomness update.
    """

    epoch: "int | None" = betterproto2.field(1, betterproto2.TYPE_UINT64, optional=True)
    """
    Epoch of the randomness state update transaction.
    """

    randomness_round: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Randomness round of the update.
    """

    random_bytes: "bytes | None" = betterproto2.field(
        3, betterproto2.TYPE_BYTES, optional=True
    )
    """
    Updated random bytes.
    """

    randomness_object_initial_shared_version: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The initial version of the randomness object that it was shared at.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "RandomnessStateUpdate", RandomnessStateUpdate
)


@dataclass(eq=False, repr=False)
class RegulatedCoinMetadata(betterproto2.Message):
    """
    Information about a regulated coin, which indicates that it makes use of the transfer deny list.
    """

    id: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    ObjectId of the `0x2::coin::RegulatedCoinMetadata` object.
    """

    coin_metadata_object: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    The ID of the coin's `CoinMetadata` or `CoinData` object.
    """

    deny_cap_object: "str | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True
    )
    """
    The ID of the coin's `DenyCap` object.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "RegulatedCoinMetadata", RegulatedCoinMetadata
)


@dataclass(eq=False, repr=False)
class SimpleSignature(betterproto2.Message):
    """
    Either an ed25519, secp256k1 or secp256r1 signature
    """

    scheme: "SignatureScheme | None" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, optional=True
    )
    """
    The signature scheme of this signature.
    """

    signature: "bytes | None" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, optional=True
    )
    """
    Signature bytes
    """

    public_key: "bytes | None" = betterproto2.field(
        3, betterproto2.TYPE_BYTES, optional=True
    )
    """
    Public key bytes
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "SimpleSignature", SimpleSignature
)


@dataclass(eq=False, repr=False)
class SimulateTransactionRequest(betterproto2.Message):
    transaction: "Transaction | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    read_mask: "___google__protobuf__.FieldMask | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    checks: "SimulateTransactionRequestTransactionChecks | None" = betterproto2.field(
        3, betterproto2.TYPE_ENUM, optional=True
    )
    """
    Specify whether checks should be ENABLED (default) or DISABLED while executing the transaction
    """

    do_gas_selection: "bool | None" = betterproto2.field(
        4, betterproto2.TYPE_BOOL, optional=True
    )
    """
    Perform gas selection based on a budget estimation and include the
    selected gas payment and budget in the response.

    This option will be ignored if `checks` is `DISABLED`.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "SimulateTransactionRequest", SimulateTransactionRequest
)


@dataclass(eq=False, repr=False)
class SimulateTransactionResponse(betterproto2.Message):
    transaction: "ExecutedTransaction | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    outputs: "list[CommandResult]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "SimulateTransactionResponse", SimulateTransactionResponse
)


@dataclass(eq=False, repr=False)
class SizeError(betterproto2.Message):
    """
    A size error.
    """

    size: "int | None" = betterproto2.field(1, betterproto2.TYPE_UINT64, optional=True)
    """
    The offending size.
    """

    max_size: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The maximum allowable size.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "SizeError", SizeError)


@dataclass(eq=False, repr=False)
class SplitCoins(betterproto2.Message):
    """
    Command to split a single coin object into multiple coins.
    """

    coin: "Argument | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The coin to split.
    """

    amounts: "list[Argument]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The amounts to split off.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "SplitCoins", SplitCoins)


@dataclass(eq=False, repr=False)
class StakeSubsidy(betterproto2.Message):
    balance: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Balance of SUI set aside for stake subsidies that will be drawn down over time.
    """

    distribution_counter: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Count of the number of times stake subsidies have been distributed.
    """

    current_distribution_amount: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The amount of stake subsidy to be drawn down per distribution.
    This amount decays and decreases over time.
    """

    stake_subsidy_period_length: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Number of distributions to occur before the distribution amount decays.
    """

    stake_subsidy_decrease_rate: "int | None" = betterproto2.field(
        5, betterproto2.TYPE_UINT32, optional=True
    )
    """
    The rate at which the distribution amount decays at the end of each
    period. Expressed in basis points.
    """

    extra_fields: "MoveTable | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Any extra fields that's not defined statically.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "StakeSubsidy", StakeSubsidy)


@dataclass(eq=False, repr=False)
class StakingPool(betterproto2.Message):
    """
    A staking pool embedded in each validator struct in the system state object.
    """

    id: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    UID of the StakingPool object
    """

    activation_epoch: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The epoch at which this pool became active.
    The value is `None` if the pool is pre-active and `Some(<epoch_number>)` if active or inactive.
    """

    deactivation_epoch: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The epoch at which this staking pool ceased to be active. `None` = {pre-active, active},
    `Some(<epoch_number>)` if in-active, and it was de-activated at epoch `<epoch_number>`.
    """

    sui_balance: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The total number of SUI tokens in this pool, including the SUI in the rewards_pool, as well as in all the principal
    in the `StakedSui` object, updated at epoch boundaries.
    """

    rewards_pool: "int | None" = betterproto2.field(
        5, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The epoch stake rewards will be added here at the end of each epoch.
    """

    pool_token_balance: "int | None" = betterproto2.field(
        6, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Total number of pool tokens issued by the pool.
    """

    exchange_rates: "MoveTable | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Exchange rate history of previous epochs.

    The entries start from the `activation_epoch` of this pool and contains exchange rates at the beginning of each epoch,
    i.e., right after the rewards for the previous epoch have been deposited into the pool.

    key: u64 (epoch number), value: PoolTokenExchangeRate
    """

    pending_stake: "int | None" = betterproto2.field(
        8, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Pending stake amount for this epoch, emptied at epoch boundaries.
    """

    pending_total_sui_withdraw: "int | None" = betterproto2.field(
        9, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Pending stake withdrawn during the current epoch, emptied at epoch boundaries.
    This includes both the principal and rewards SUI withdrawn.
    """

    pending_pool_token_withdraw: "int | None" = betterproto2.field(
        10, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Pending pool token withdrawn during the current epoch, emptied at epoch boundaries.
    """

    extra_fields: "MoveTable | None" = betterproto2.field(
        11, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Any extra fields that's not defined statically.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "StakingPool", StakingPool)


@dataclass(eq=False, repr=False)
class StorageFund(betterproto2.Message):
    """
    Struct representing the onchain storage fund.
    """

    total_object_storage_rebates: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_UINT64, optional=True
    )
    """
    This is the sum of `storage_rebate` of
    all objects currently stored on-chain. To maintain this invariant, the only inflow of this
    balance is storage charges collected from transactions, and the only outflow is storage rebates
    of transactions, including both the portion refunded to the transaction senders as well as
    the non-refundable portion taken out and put into `non_refundable_balance`.
    """

    non_refundable_balance: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Represents any remaining inflow of the storage fund that should not
    be taken out of the fund.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "StorageFund", StorageFund)


@dataclass(eq=False, repr=False)
class SubscribeCheckpointsRequest(betterproto2.Message):
    """
    Request message for SubscriptionService.SubscribeCheckpoints
    """

    read_mask: "___google__protobuf__.FieldMask | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Optional. Mask for specifiying which parts of the
    SubscribeCheckpointsResponse should be returned.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "SubscribeCheckpointsRequest", SubscribeCheckpointsRequest
)


@dataclass(eq=False, repr=False)
class SubscribeCheckpointsResponse(betterproto2.Message):
    """
    Response message for SubscriptionService.SubscribeCheckpoints
    """

    cursor: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Required. The checkpoint sequence number and value of the current cursor
    into the checkpoint stream
    """

    checkpoint: "Checkpoint | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The requested data for this checkpoint
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "SubscribeCheckpointsResponse", SubscribeCheckpointsResponse
)


@dataclass(eq=False, repr=False)
class SystemPackage(betterproto2.Message):
    """
    System package.
    """

    version: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Version of the package.
    """

    modules: "list[bytes]" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, repeated=True
    )
    """
    Move modules.
    """

    dependencies: "list[str]" = betterproto2.field(
        3, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Package dependencies.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "SystemPackage", SystemPackage)


@dataclass(eq=False, repr=False)
class SystemParameters(betterproto2.Message):
    epoch_duration_ms: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The duration of an epoch, in milliseconds.
    """

    stake_subsidy_start_epoch: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The starting epoch in which stake subsidies start being paid out
    """

    min_validator_count: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Minimum number of active validators at any moment.
    """

    max_validator_count: "int | None" = betterproto2.field(
        4, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Maximum number of active validators at any moment.
    We do not allow the number of validators in any epoch to go above this.
    """

    min_validator_joining_stake: "int | None" = betterproto2.field(
        5, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Deprecated.
    Lower-bound on the amount of stake required to become a validator.
    """

    validator_low_stake_threshold: "int | None" = betterproto2.field(
        6, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Deprecated.
    Validators with stake amount below `validator_low_stake_threshold` are considered to
    have low stake and will be escorted out of the validator set after being below this
    threshold for more than `validator_low_stake_grace_period` number of epochs.
    """

    validator_very_low_stake_threshold: "int | None" = betterproto2.field(
        7, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Deprecated.
    Validators with stake below `validator_very_low_stake_threshold` will be removed
    immediately at epoch change, no grace period.
    """

    validator_low_stake_grace_period: "int | None" = betterproto2.field(
        8, betterproto2.TYPE_UINT64, optional=True
    )
    """
    A validator can have stake below `validator_low_stake_threshold`
    for this many epochs before being kicked out.
    """

    extra_fields: "MoveTable | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Any extra fields that are not defined statically.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "SystemParameters", SystemParameters
)


@dataclass(eq=False, repr=False)
class SystemState(betterproto2.Message):
    version: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The version of the system state data structure type.
    """

    epoch: "int | None" = betterproto2.field(2, betterproto2.TYPE_UINT64, optional=True)
    """
    The epoch id
    """

    protocol_version: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The protocol version
    """

    validators: "ValidatorSet | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Information about the validators
    """

    storage_fund: "StorageFund | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Storage Fund info
    """

    parameters: "SystemParameters | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Set of system config parameters
    """

    reference_gas_price: "int | None" = betterproto2.field(
        7, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The reference gas price for this epoch
    """

    validator_report_records: "list[ValidatorReportRecord]" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    A list of the records of validator reporting each other.

    There is an entry in this list for each validator that has been reported
    at least once. Each record contains all the validators that reported
    them. If a validator has never been reported they don't have a record in this list.
    This lists persists across epoch: a peer continues being in a reported state until the
    reporter doesn't explicitly remove their report.
    """

    stake_subsidy: "StakeSubsidy | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Schedule of stake subsidies given out each epoch.
    """

    safe_mode: "bool | None" = betterproto2.field(
        10, betterproto2.TYPE_BOOL, optional=True
    )
    """
    Whether the system is running in a downgraded safe mode due to a non-recoverable bug.
    This is set whenever we failed to execute advance_epoch, and ended up executing advance_epoch_safe_mode.
    It can be reset once we are able to successfully execute advance_epoch.
    The rest of the fields starting with `safe_mode_` are accumulated during safe mode
    when advance_epoch_safe_mode is executed. They will eventually be processed once we
    are out of safe mode.
    """

    safe_mode_storage_rewards: "int | None" = betterproto2.field(
        11, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Storage rewards accumulated during safe_mode
    """

    safe_mode_computation_rewards: "int | None" = betterproto2.field(
        12, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Computation rewards accumulated during safe_mode
    """

    safe_mode_storage_rebates: "int | None" = betterproto2.field(
        13, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Storage rebates paid out during safe_mode
    """

    safe_mode_non_refundable_storage_fee: "int | None" = betterproto2.field(
        14, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Nonrefundable storage fees accumulated during safe_mode
    """

    epoch_start_timestamp_ms: "int | None" = betterproto2.field(
        15, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Unix timestamp of when this this epoch started
    """

    extra_fields: "MoveTable | None" = betterproto2.field(
        16, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Any extra fields that's not defined statically.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "SystemState", SystemState)


@dataclass(eq=False, repr=False)
class Transaction(betterproto2.Message):
    """
    A transaction.
    """

    bcs: "Bcs | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    """
    This Transaction serialized as BCS.
    """

    digest: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    The digest of this Transaction.
    """

    version: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_INT32, optional=True
    )
    """
    Version of this Transaction.
    """

    kind: "TransactionKind | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )

    sender: "str | None" = betterproto2.field(
        5, betterproto2.TYPE_STRING, optional=True
    )

    gas_payment: "GasPayment | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )

    expiration: "TransactionExpiration | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("sui.rpc.v2beta2", "Transaction", Transaction)


@dataclass(eq=False, repr=False)
class TransactionEffects(betterproto2.Message):
    """
    The effects of executing a transaction.
    """

    bcs: "Bcs | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    """
    This TransactionEffects serialized as BCS.
    """

    digest: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    The digest of this TransactionEffects.
    """

    version: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_INT32, optional=True
    )
    """
    Version of this TransactionEffects.
    """

    status: "ExecutionStatus | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The status of the execution.
    """

    epoch: "int | None" = betterproto2.field(5, betterproto2.TYPE_UINT64, optional=True)
    """
    The epoch when this transaction was executed.
    """

    gas_used: "GasCostSummary | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The gas used by this transaction.
    """

    transaction_digest: "str | None" = betterproto2.field(
        7, betterproto2.TYPE_STRING, optional=True
    )
    """
    The transaction digest.
    """

    gas_object: "ChangedObject | None" = betterproto2.field(
        8, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Information about the gas object. Also present in the `changed_objects` vector.

    System transaction that don't require gas will leave this as `None`.
    """

    events_digest: "str | None" = betterproto2.field(
        9, betterproto2.TYPE_STRING, optional=True
    )
    """
    The digest of the events emitted during execution,
    can be `None` if the transaction does not emit any event.
    """

    dependencies: "list[str]" = betterproto2.field(
        10, betterproto2.TYPE_STRING, repeated=True
    )
    """
    The set of transaction digests this transaction depends on.
    """

    lamport_version: "int | None" = betterproto2.field(
        11, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The version number of all the written objects (excluding packages) by this transaction.
    """

    changed_objects: "list[ChangedObject]" = betterproto2.field(
        12, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Objects whose state are changed by this transaction.
    """

    unchanged_shared_objects: "list[UnchangedSharedObject]" = betterproto2.field(
        13, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Shared objects that are not mutated in this transaction. Unlike owned objects,
    read-only shared objects' version are not committed in the transaction,
    and in order for a node to catch up and execute it without consensus sequencing,
    the version needs to be committed in the effects.
    """

    auxiliary_data_digest: "str | None" = betterproto2.field(
        14, betterproto2.TYPE_STRING, optional=True
    )
    """
    Auxiliary data that are not protocol-critical, generated as part of the effects but are stored separately.
    Storing it separately allows us to avoid bloating the effects with data that are not critical.
    It also provides more flexibility on the format and type of the data.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "TransactionEffects", TransactionEffects
)


@dataclass(eq=False, repr=False)
class TransactionEvents(betterproto2.Message):
    """
    Events emitted during the successful execution of a transaction.
    """

    bcs: "Bcs | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    """
    This TransactionEvents serialized as BCS.
    """

    digest: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    The digest of this TransactionEvents.
    """

    events: "list[Event]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Set of events emitted by a transaction.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "TransactionEvents", TransactionEvents
)


@dataclass(eq=False, repr=False)
class TransactionExpiration(betterproto2.Message):
    """
    A TTL for a transaction.
    """

    kind: "TransactionExpirationTransactionExpirationKind | None" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, optional=True
    )

    epoch: "int | None" = betterproto2.field(2, betterproto2.TYPE_UINT64, optional=True)


default_message_pool.register_message(
    "sui.rpc.v2beta2", "TransactionExpiration", TransactionExpiration
)


@dataclass(eq=False, repr=False)
class TransactionFinality(betterproto2.Message):
    """
    Indicates the finality of the executed transaction.

    Oneofs:
        - finality:
    """

    certified: "ValidatorAggregatedSignature | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True, group="finality"
    )
    """
    A quorum certificate certifying that a transaction is final but might not
    be included in a checkpoint yet.
    """

    checkpointed: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True, group="finality"
    )
    """
    Sequence number of the checkpoint that includes the transaction.
    """

    quorum_executed: "___google__protobuf__.Empty | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="finality"
    )
    """
    Indicates that a quorum of validators has executed the transaction but
    that it might not be included in a checkpoint yet.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "TransactionFinality", TransactionFinality
)


@dataclass(eq=False, repr=False)
class TransactionKind(betterproto2.Message):
    """
    Transaction type.

    Oneofs:
        - kind:
    """

    programmable_transaction: "ProgrammableTransaction | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    A user transaction comprised of a list of native commands and Move calls.
    """

    programmable_system_transaction: "ProgrammableTransaction | None" = (
        betterproto2.field(3, betterproto2.TYPE_MESSAGE, optional=True, group="kind")
    )
    """
    System Transactions

    A system transaction comprised of a list of native commands and Move calls.
    """

    change_epoch: "ChangeEpoch | None" = betterproto2.field(
        100, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    System transaction used to end an epoch.

    The `ChangeEpoch` variant is now deprecated (but the `ChangeEpoch` struct is still used by
    `EndOfEpochTransaction`).
    """

    genesis: "GenesisTransaction | None" = betterproto2.field(
        101, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    Transaction used to initialize the chain state.

    Only valid if in the genesis checkpoint (0) and if this is the very first transaction ever
    executed on the chain.
    """

    consensus_commit_prologue_v1: "ConsensusCommitPrologue | None" = betterproto2.field(
        102, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    V1 consensus commit update.
    """

    authenticator_state_update: "AuthenticatorStateUpdate | None" = betterproto2.field(
        103, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    Update set of valid JWKs used for zklogin.
    """

    end_of_epoch: "EndOfEpochTransaction | None" = betterproto2.field(
        104, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    Set of operations to run at the end of the epoch to close out the current epoch and start
    the next one.
    """

    randomness_state_update: "RandomnessStateUpdate | None" = betterproto2.field(
        105, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    Randomness update.
    """

    consensus_commit_prologue_v2: "ConsensusCommitPrologue | None" = betterproto2.field(
        106, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    V2 consensus commit update.
    """

    consensus_commit_prologue_v3: "ConsensusCommitPrologue | None" = betterproto2.field(
        107, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    V3 consensus commit update.
    """

    consensus_commit_prologue_v4: "ConsensusCommitPrologue | None" = betterproto2.field(
        108, betterproto2.TYPE_MESSAGE, optional=True, group="kind"
    )
    """
    V4 consensus commit update.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "TransactionKind", TransactionKind
)


@dataclass(eq=False, repr=False)
class TransferObjects(betterproto2.Message):
    """
    Command to transfer ownership of a set of objects to an address.
    """

    objects: "list[Argument]" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Set of objects to transfer.
    """

    address: "Argument | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The address to transfer ownership to.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "TransferObjects", TransferObjects
)


@dataclass(eq=False, repr=False)
class TypeArgumentError(betterproto2.Message):
    """
    Type argument error.
    """

    type_argument: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_UINT32, optional=True
    )
    """
    Index of the problematic type argument.
    """

    kind: "TypeArgumentErrorTypeArgumentErrorKind | None" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, optional=True
    )


default_message_pool.register_message(
    "sui.rpc.v2beta2", "TypeArgumentError", TypeArgumentError
)


@dataclass(eq=False, repr=False)
class TypeOrigin(betterproto2.Message):
    """
    Identifies a struct and the module it was defined in.
    """

    module_name: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )

    datatype_name: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )

    package_id: "str | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True
    )


default_message_pool.register_message("sui.rpc.v2beta2", "TypeOrigin", TypeOrigin)


@dataclass(eq=False, repr=False)
class TypeParameter(betterproto2.Message):
    """
    A generic type parameter used in the declaration of a struct or enum.
    """

    constraints: "list[Ability]" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, repeated=True
    )
    """
    The type parameter constraints
    """

    is_phantom: "bool | None" = betterproto2.field(
        2, betterproto2.TYPE_BOOL, optional=True
    )
    """
    Whether the parameter is declared as phantom
    """


default_message_pool.register_message("sui.rpc.v2beta2", "TypeParameter", TypeParameter)


@dataclass(eq=False, repr=False)
class UnchangedSharedObject(betterproto2.Message):
    """
    A shared object that wasn't changed during execution.
    """

    kind: "UnchangedSharedObjectUnchangedSharedObjectKind | None" = betterproto2.field(
        1, betterproto2.TYPE_ENUM, optional=True
    )

    object_id: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    ObjectId of the shared object.
    """

    version: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Version of the shared object.
    """

    digest: "str | None" = betterproto2.field(
        4, betterproto2.TYPE_STRING, optional=True
    )
    """
    Digest of the shared object.
    """

    object_type: "str | None" = betterproto2.field(
        5, betterproto2.TYPE_STRING, optional=True
    )
    """
    Type information is not provided by the effects structure but is instead
    provided by an indexing layer
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "UnchangedSharedObject", UnchangedSharedObject
)


@dataclass(eq=False, repr=False)
class Upgrade(betterproto2.Message):
    """
    Command to upgrade an already published package.
    """

    modules: "list[bytes]" = betterproto2.field(
        1, betterproto2.TYPE_BYTES, repeated=True
    )
    """
    The serialized Move modules.
    """

    dependencies: "list[str]" = betterproto2.field(
        2, betterproto2.TYPE_STRING, repeated=True
    )
    """
    Set of packages that the to-be published package depends on.
    """

    package: "str | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True
    )
    """
    Package ID of the package to upgrade.
    """

    ticket: "Argument | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Ticket authorizing the upgrade.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "Upgrade", Upgrade)


@dataclass(eq=False, repr=False)
class UserSignature(betterproto2.Message):
    """
    A signature from a user.

    Oneofs:
        - signature:
    """

    bcs: "Bcs | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)
    """
    This signature serialized as as BCS.

    When provided as input this will support both the form that is length
    prefixed as well as not length prefixed.
    """

    scheme: "SignatureScheme | None" = betterproto2.field(
        2, betterproto2.TYPE_ENUM, optional=True
    )
    """
    The signature scheme of this signature.
    """

    simple: "SimpleSignature | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True, group="signature"
    )
    """
    Simple signature if scheme is ed25519 | secp256k1 | secp256r1.
    """

    multisig: "MultisigAggregatedSignature | None" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, optional=True, group="signature"
    )
    """
    The multisig aggregated signature if scheme is `MULTISIG`.
    """

    zklogin: "ZkLoginAuthenticator | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True, group="signature"
    )
    """
    The zklogin authenticator if scheme is `ZKLOGIN`.
    """

    passkey: "PasskeyAuthenticator | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True, group="signature"
    )
    """
    The passkey authenticator if scheme is `PASSKEY`.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "UserSignature", UserSignature)


@dataclass(eq=False, repr=False)
class Validator(betterproto2.Message):
    """
    Definition of a Validator in the system contracts

    Note: fields of ValidatorMetadata are flattened into this type
    """

    name: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    A unique human-readable name of this validator.
    """

    address: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    The Sui Address of the validator. This is the sender that created the Validator object,
    and also the address to send validator/coins to during withdraws.
    """

    description: "str | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True
    )

    image_url: "str | None" = betterproto2.field(
        4, betterproto2.TYPE_STRING, optional=True
    )

    project_url: "str | None" = betterproto2.field(
        5, betterproto2.TYPE_STRING, optional=True
    )

    protocol_public_key: "bytes | None" = betterproto2.field(
        7, betterproto2.TYPE_BYTES, optional=True
    )
    """
    The public key bytes corresponding to the private key that the validator
    holds to sign transactions. For now, this is the same as AuthorityName.
    """

    proof_of_possession: "bytes | None" = betterproto2.field(
        8, betterproto2.TYPE_BYTES, optional=True
    )
    """
    This is a proof that the validator has ownership of the protocol private key
    """

    network_public_key: "bytes | None" = betterproto2.field(
        10, betterproto2.TYPE_BYTES, optional=True
    )
    """
    The public key bytes corresponding to the private key that the validator
    uses to establish TLS connections
    """

    worker_public_key: "bytes | None" = betterproto2.field(
        12, betterproto2.TYPE_BYTES, optional=True
    )
    """
    The public key bytes correstponding to the Narwhal Worker
    """

    network_address: "str | None" = betterproto2.field(
        13, betterproto2.TYPE_STRING, optional=True
    )
    """
    The network address of the validator (could also contain extra info such as port, DNS and etc.).
    """

    p2p_address: "str | None" = betterproto2.field(
        14, betterproto2.TYPE_STRING, optional=True
    )
    """
    The address of the validator used for p2p activities such as state sync (could also contain extra info such as port, DNS and etc.).
    """

    primary_address: "str | None" = betterproto2.field(
        15, betterproto2.TYPE_STRING, optional=True
    )
    """
    The address of the narwhal primary
    """

    worker_address: "str | None" = betterproto2.field(
        16, betterproto2.TYPE_STRING, optional=True
    )
    """
    The address of the narwhal worker
    """

    next_epoch_protocol_public_key: "bytes | None" = betterproto2.field(
        18, betterproto2.TYPE_BYTES, optional=True
    )

    next_epoch_proof_of_possession: "bytes | None" = betterproto2.field(
        19, betterproto2.TYPE_BYTES, optional=True
    )

    next_epoch_network_public_key: "bytes | None" = betterproto2.field(
        21, betterproto2.TYPE_BYTES, optional=True
    )

    next_epoch_worker_public_key: "bytes | None" = betterproto2.field(
        23, betterproto2.TYPE_BYTES, optional=True
    )

    next_epoch_network_address: "str | None" = betterproto2.field(
        24, betterproto2.TYPE_STRING, optional=True
    )

    next_epoch_p2p_address: "str | None" = betterproto2.field(
        25, betterproto2.TYPE_STRING, optional=True
    )

    next_epoch_primary_address: "str | None" = betterproto2.field(
        26, betterproto2.TYPE_STRING, optional=True
    )

    next_epoch_worker_address: "str | None" = betterproto2.field(
        27, betterproto2.TYPE_STRING, optional=True
    )

    metadata_extra_fields: "MoveTable | None" = betterproto2.field(
        28, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Any extra fields that's not defined statically in the `ValidatorMetadata` struct
    """

    voting_power: "int | None" = betterproto2.field(
        29, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The voting power of this validator, which might be different from its
    stake amount.
    """

    operation_cap_id: "str | None" = betterproto2.field(
        30, betterproto2.TYPE_STRING, optional=True
    )
    """
    The ID of this validator's current valid `UnverifiedValidatorOperationCap`
    """

    gas_price: "int | None" = betterproto2.field(
        31, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Gas price quote, updated only at end of epoch.
    """

    staking_pool: "StakingPool | None" = betterproto2.field(
        32, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Staking pool for this validator.
    """

    commission_rate: "int | None" = betterproto2.field(
        33, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Commission rate of the validator, in basis point.
    """

    next_epoch_stake: "int | None" = betterproto2.field(
        34, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Total amount of stake that would be active in the next epoch.
    """

    next_epoch_gas_price: "int | None" = betterproto2.field(
        35, betterproto2.TYPE_UINT64, optional=True
    )
    """
    This validator's gas price quote for the next epoch.
    """

    next_epoch_commission_rate: "int | None" = betterproto2.field(
        36, betterproto2.TYPE_UINT64, optional=True
    )
    """
    The commission rate of the validator starting the next epoch, in basis point.
    """

    extra_fields: "MoveTable | None" = betterproto2.field(
        37, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Any extra fields that's not defined statically.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "Validator", Validator)


@dataclass(eq=False, repr=False)
class ValidatorAggregatedSignature(betterproto2.Message):
    """
    / An aggregated signature from multiple validators.
    """

    epoch: "int | None" = betterproto2.field(1, betterproto2.TYPE_UINT64, optional=True)
    """
    The epoch when this signature was produced.

    This can be used to lookup the `ValidatorCommittee` from this epoch
    to verify this signature.
    """

    signature: "bytes | None" = betterproto2.field(
        2, betterproto2.TYPE_BYTES, optional=True
    )
    """
    The 48-byte Bls12381 aggregated signature.
    """

    bitmap: "list[int]" = betterproto2.field(3, betterproto2.TYPE_UINT32, repeated=True)
    """
    Bitmap indicating which members of the committee contributed to
    this signature.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ValidatorAggregatedSignature", ValidatorAggregatedSignature
)


@dataclass(eq=False, repr=False)
class ValidatorCommittee(betterproto2.Message):
    """
    The validator set for a particular epoch.
    """

    epoch: "int | None" = betterproto2.field(1, betterproto2.TYPE_UINT64, optional=True)
    """
    The epoch where this committee governs.
    """

    members: "list[ValidatorCommitteeMember]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The committee members.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ValidatorCommittee", ValidatorCommittee
)


@dataclass(eq=False, repr=False)
class ValidatorCommitteeMember(betterproto2.Message):
    """
    A member of a validator committee.
    """

    public_key: "bytes | None" = betterproto2.field(
        1, betterproto2.TYPE_BYTES, optional=True
    )
    """
    The 96-byte Bls12381 public key for this validator.
    """

    weight: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    voting weight this validator possesses.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ValidatorCommitteeMember", ValidatorCommitteeMember
)


@dataclass(eq=False, repr=False)
class ValidatorExecutionTimeObservation(betterproto2.Message):
    validator: "bytes | None" = betterproto2.field(
        1, betterproto2.TYPE_BYTES, optional=True
    )
    """
    Bls12381 public key of the validator
    """

    duration: "datetime.timedelta | None" = betterproto2.field(
        2,
        betterproto2.TYPE_MESSAGE,
        unwrap=lambda: ___google__protobuf__.Duration,
        optional=True,
    )
    """
    Duration of an execution observation
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2",
    "ValidatorExecutionTimeObservation",
    ValidatorExecutionTimeObservation,
)


@dataclass(eq=False, repr=False)
class ValidatorReportRecord(betterproto2.Message):
    reported: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    The address of the validator being reported
    """

    reporters: "list[str]" = betterproto2.field(
        2, betterproto2.TYPE_STRING, repeated=True
    )
    """
    The list of validator (addresses) that are reporting on the validator specified by `reported`
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ValidatorReportRecord", ValidatorReportRecord
)


@dataclass(eq=False, repr=False)
class ValidatorSet(betterproto2.Message):
    total_stake: "int | None" = betterproto2.field(
        1, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Total amount of stake from all active validators at the beginning of the epoch.
    Written only once per epoch, in `advance_epoch` function.
    """

    active_validators: "list[Validator]" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The current list of active validators.
    """

    pending_active_validators: "MoveTable | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    List of new validator candidates added during the current epoch.
    They will be processed at the end of the epoch.

    key: u64 (index), value: 0x3::validator::Validator
    """

    pending_removals: "list[int]" = betterproto2.field(
        4, betterproto2.TYPE_UINT64, repeated=True
    )
    """
    Removal requests from the validators. Each element is an index
    pointing to `active_validators`.
    """

    staking_pool_mappings: "MoveTable | None" = betterproto2.field(
        5, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Mappings from staking pool's ID to the sui address of a validator.

    key: address (staking pool Id), value: address (sui address of the validator)
    """

    inactive_validators: "MoveTable | None" = betterproto2.field(
        6, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Mapping from a staking pool ID to the inactive validator that has that pool as its staking pool.
    When a validator is deactivated the validator is removed from `active_validators` it
    is added to this table so that stakers can continue to withdraw their stake from it.

    key: address (staking pool Id), value: 0x3::validator_wrapper::ValidatorWrapper
    """

    validator_candidates: "MoveTable | None" = betterproto2.field(
        7, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Table storing preactive/candidate validators, mapping their addresses to their `Validator ` structs.
    When an address calls `request_add_validator_candidate`, they get added to this table and become a preactive
    validator.
    When the candidate has met the min stake requirement, they can call `request_add_validator` to
    officially add them to the active validator set `active_validators` next epoch.

    key: address (sui address of the validator), value: 0x3::validator_wrapper::ValidatorWrapper
    """

    at_risk_validators: "dict[str, int]" = betterproto2.field(
        8,
        betterproto2.TYPE_MAP,
        map_meta=betterproto2.map_meta(
            betterproto2.TYPE_STRING, betterproto2.TYPE_UINT64
        ),
    )
    """
    Table storing the number of epochs during which a validator's stake has been below the low stake threshold.
    """

    extra_fields: "MoveTable | None" = betterproto2.field(
        9, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Any extra fields that's not defined statically.
    """


default_message_pool.register_message("sui.rpc.v2beta2", "ValidatorSet", ValidatorSet)


@dataclass(eq=False, repr=False)
class VariantDescriptor(betterproto2.Message):
    """
    Descriptor of an enum variant
    """

    name: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)
    """
    Name of the variant
    """

    position: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT32, optional=True
    )
    """
    Order or position of the variant in the enum definition.
    """

    fields: "list[FieldDescriptor]" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    Set of fields defined by this variant.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "VariantDescriptor", VariantDescriptor
)


@dataclass(eq=False, repr=False)
class VerifySignatureRequest(betterproto2.Message):
    message: "Bcs | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The message to verify against.

    Today the only supported message types are `PersonalMessage` and
    `TransactionData` and the `Bcs.name` must be set to indicate which type of
    message is being verified.
    """

    signature: "UserSignature | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    The siganture to verify.
    """

    address: "str | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True
    )
    """
    Optional. Address to validate against the provided signature.

    If provided, this address will be compared against the the address derived
    from the provide signature and a successful response will only be returned
    if they match.
    """

    jwks: "list[ActiveJwk]" = betterproto2.field(
        4, betterproto2.TYPE_MESSAGE, repeated=True
    )
    """
    The set of JWKs to use when verifying Zklogin signatures.
    If this is empty the current set of valid JWKs stored onchain will be used
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "VerifySignatureRequest", VerifySignatureRequest
)


@dataclass(eq=False, repr=False)
class VerifySignatureResponse(betterproto2.Message):
    is_valid: "bool | None" = betterproto2.field(
        1, betterproto2.TYPE_BOOL, optional=True
    )
    """
    Indicates if the provided signature was valid given the requested parameters.
    """

    reason: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    If `is_valid` is `false`, this is the reason for why the signature verification failed.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "VerifySignatureResponse", VerifySignatureResponse
)


@dataclass(eq=False, repr=False)
class VersionAssignment(betterproto2.Message):
    """
    Object version assignment from consensus.
    """

    object_id: "str | None" = betterproto2.field(
        1, betterproto2.TYPE_STRING, optional=True
    )
    """
    `ObjectId` of the object.
    """

    start_version: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    start version of the consensus stream for this object
    """

    version: "int | None" = betterproto2.field(
        3, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Assigned version.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "VersionAssignment", VersionAssignment
)


@dataclass(eq=False, repr=False)
class ZkLoginAuthenticator(betterproto2.Message):
    """
    A zklogin authenticator.
    """

    inputs: "ZkLoginInputs | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    Zklogin proof and inputs required to perform proof verification.
    """

    max_epoch: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT64, optional=True
    )
    """
    Maximum epoch for which the proof is valid.
    """

    signature: "SimpleSignature | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )
    """
    User signature with the public key attested to by the provided proof.
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ZkLoginAuthenticator", ZkLoginAuthenticator
)


@dataclass(eq=False, repr=False)
class ZkLoginClaim(betterproto2.Message):
    """
    A claim of the iss in a zklogin proof.
    """

    value: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)

    index_mod_4: "int | None" = betterproto2.field(
        2, betterproto2.TYPE_UINT32, optional=True
    )


default_message_pool.register_message("sui.rpc.v2beta2", "ZkLoginClaim", ZkLoginClaim)


@dataclass(eq=False, repr=False)
class ZkLoginInputs(betterproto2.Message):
    """
    A zklogin groth16 proof and the required inputs to perform proof verification.
    """

    proof_points: "ZkLoginProof | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    iss_base64_details: "ZkLoginClaim | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    header_base64: "str | None" = betterproto2.field(
        3, betterproto2.TYPE_STRING, optional=True
    )

    address_seed: "str | None" = betterproto2.field(
        4, betterproto2.TYPE_STRING, optional=True
    )
    """
    base10 encoded Bn254FieldElement
    """


default_message_pool.register_message("sui.rpc.v2beta2", "ZkLoginInputs", ZkLoginInputs)


@dataclass(eq=False, repr=False)
class ZkLoginProof(betterproto2.Message):
    """
    A zklogin groth16 proof.
    """

    a: "CircomG1 | None" = betterproto2.field(
        1, betterproto2.TYPE_MESSAGE, optional=True
    )

    b: "CircomG2 | None" = betterproto2.field(
        2, betterproto2.TYPE_MESSAGE, optional=True
    )

    c: "CircomG1 | None" = betterproto2.field(
        3, betterproto2.TYPE_MESSAGE, optional=True
    )


default_message_pool.register_message("sui.rpc.v2beta2", "ZkLoginProof", ZkLoginProof)


@dataclass(eq=False, repr=False)
class ZkLoginPublicIdentifier(betterproto2.Message):
    """
    Public key equivalent for zklogin authenticators.
    """

    iss: "str | None" = betterproto2.field(1, betterproto2.TYPE_STRING, optional=True)

    address_seed: "str | None" = betterproto2.field(
        2, betterproto2.TYPE_STRING, optional=True
    )
    """
    base10 encoded Bn254FieldElement
    """


default_message_pool.register_message(
    "sui.rpc.v2beta2", "ZkLoginPublicIdentifier", ZkLoginPublicIdentifier
)


class LedgerServiceStub(betterproto2.ServiceStub):
    async def get_service_info(
        self,
        message: "GetServiceInfoRequest | None" = None,
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "GetServiceInfoResponse":
        """
        Query the service for general information about its current state.
        """

        if message is None:
            message = GetServiceInfoRequest()

        return await self._unary_unary(
            "/sui.rpc.v2beta2.LedgerService/GetServiceInfo",
            message,
            GetServiceInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_object(
        self,
        message: "GetObjectRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "GetObjectResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.LedgerService/GetObject",
            message,
            GetObjectResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def batch_get_objects(
        self,
        message: "BatchGetObjectsRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "BatchGetObjectsResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.LedgerService/BatchGetObjects",
            message,
            BatchGetObjectsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_transaction(
        self,
        message: "GetTransactionRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "GetTransactionResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.LedgerService/GetTransaction",
            message,
            GetTransactionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def batch_get_transactions(
        self,
        message: "BatchGetTransactionsRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "BatchGetTransactionsResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.LedgerService/BatchGetTransactions",
            message,
            BatchGetTransactionsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_checkpoint(
        self,
        message: "GetCheckpointRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "GetCheckpointResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.LedgerService/GetCheckpoint",
            message,
            GetCheckpointResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_epoch(
        self,
        message: "GetEpochRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "GetEpochResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.LedgerService/GetEpoch",
            message,
            GetEpochResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class LiveDataServiceStub(betterproto2.ServiceStub):
    async def list_dynamic_fields(
        self,
        message: "ListDynamicFieldsRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ListDynamicFieldsResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.LiveDataService/ListDynamicFields",
            message,
            ListDynamicFieldsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_owned_objects(
        self,
        message: "ListOwnedObjectsRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ListOwnedObjectsResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.LiveDataService/ListOwnedObjects",
            message,
            ListOwnedObjectsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_coin_info(
        self,
        message: "GetCoinInfoRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "GetCoinInfoResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.LiveDataService/GetCoinInfo",
            message,
            GetCoinInfoResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_balance(
        self,
        message: "GetBalanceRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "GetBalanceResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.LiveDataService/GetBalance",
            message,
            GetBalanceResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_balances(
        self,
        message: "ListBalancesRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ListBalancesResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.LiveDataService/ListBalances",
            message,
            ListBalancesResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def simulate_transaction(
        self,
        message: "SimulateTransactionRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "SimulateTransactionResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.LiveDataService/SimulateTransaction",
            message,
            SimulateTransactionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class MovePackageServiceStub(betterproto2.ServiceStub):
    async def get_package(
        self,
        message: "GetPackageRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "GetPackageResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.MovePackageService/GetPackage",
            message,
            GetPackageResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_datatype(
        self,
        message: "GetDatatypeRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "GetDatatypeResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.MovePackageService/GetDatatype",
            message,
            GetDatatypeResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def get_function(
        self,
        message: "GetFunctionRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "GetFunctionResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.MovePackageService/GetFunction",
            message,
            GetFunctionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )

    async def list_package_versions(
        self,
        message: "ListPackageVersionsRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ListPackageVersionsResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.MovePackageService/ListPackageVersions",
            message,
            ListPackageVersionsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class SignatureVerificationServiceStub(betterproto2.ServiceStub):
    async def verify_signature(
        self,
        message: "VerifySignatureRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "VerifySignatureResponse":
        """
        Perform signature verification of a UserSignature against the provided message.
        """

        return await self._unary_unary(
            "/sui.rpc.v2beta2.SignatureVerificationService/VerifySignature",
            message,
            VerifySignatureResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class SubscriptionServiceStub(betterproto2.ServiceStub):
    async def subscribe_checkpoints(
        self,
        message: "SubscribeCheckpointsRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "AsyncIterator[SubscribeCheckpointsResponse]":
        """
        Subscribe to the stream of checkpoints.

        This API provides a subscription to the checkpoint stream for the Sui
        blockchain. When a subscription is initialized the stream will begin with
        the latest executed checkpoint as seen by the server. Responses are
        guaranteed to return checkpoints in-order and without gaps. This enables
        clients to know exactly the last checkpoint they have processed and in the
        event the subscription terminates (either by the client/server or by the
        connection breaking), clients will be able to reinitailize a subscription
        and then leverage other APIs in order to request data for the checkpoints
        they missed.
        """

        async for response in self._unary_stream(
            "/sui.rpc.v2beta2.SubscriptionService/SubscribeCheckpoints",
            message,
            SubscribeCheckpointsResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        ):
            yield response


class TransactionExecutionServiceStub(betterproto2.ServiceStub):
    async def execute_transaction(
        self,
        message: "ExecuteTransactionRequest",
        *,
        timeout: "float | None" = None,
        deadline: "Deadline | None" = None,
        metadata: "MetadataLike | None" = None,
    ) -> "ExecuteTransactionResponse":
        return await self._unary_unary(
            "/sui.rpc.v2beta2.TransactionExecutionService/ExecuteTransaction",
            message,
            ExecuteTransactionResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


from ....google import protobuf as ___google__protobuf__
from ....google import rpc as ___google__rpc__
